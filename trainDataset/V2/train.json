[
    {
        "Statement": "take n (x:xs) = x : take (n-1) xs",
        "Description": "Otherwise, take `n` elements from the list."
    },
    {
        "Statement": "toUpperCase = map toUpper",
        "Description": "Use the `map` function with `toUpper` to convert each character in the input string to uppercase."
    },
    {
        "Statement": "con \"absolute\" (abs :: Int -> Int),",
        "Description": "Include the 'absolute' function signature."
    },
    {
        "Statement": "bSort [] acc = acc",
        "Description": "If the input list is empty, return the accumulator."
    },
    {
        "Statement": "con \"[]\" ([] :: [A]),",
        "Description": "Declare the constant '[]' as an empty list."
    },
    {
        "Statement": "import Quickspec",
        "Description": "Import the Quickspec module."
    },
    {
        "Statement": "instance Monad Maybe",
        "Description": "Create an instance of the Monad typeclass for the Maybe data type, which represents computations that can either succeed with a value of type a or fail without a value."
    },
    {
        "Statement": "checkInput (x:_) = isUpper x",
        "Description": "If the input String is non-empty, check if the first character is an uppercase letter using the isUpper function, and return the result as a Bool."
    },
    {
        "Statement": "f acc [] = reverse acc",
        "Description": "If the input string is empty, 'f' returns the accumulated characters in reverse order."
    },
    {
        "Statement": "import qualified Module",
        "Description": "Imports all entities from the module 'Module' but qualifies them with the module name, so they need to be accessed using the module name prefix."
    },
    {
        "Statement": "liftIOm io :: io >>= retrunIOM",
        "Description": "Define liftIOm io as io >>= returnIOM."
    },
    {
        "Statement": "treeToSet Leaf = empty",
        "Description": "For an empty tree, return an empty set."
    },
    {
        "Statement": "con \"uppercase\" (map toUpper :: String -> String),",
        "Description": "Include the 'uppercase' function signature."
    },
    {
        "Statement": "group :: Eq a => Seq a -> Seq (Seq a)",
        "Description": "Declare a function group that groups adjacent elements in a sequence."
    },
    {
        "Statement": "assumes",
        "Description": "Specify assumptions for the lemma."
    },
    {
        "Statement": "splice xs [] = xs",
        "Description": "If the second list is empty, return the first list xs as the result of splicing."
    },
    {
        "Statement": "liftIOm io :: io >>= returnIOM",
        "Description": "Implement the liftIOm function by binding the result of the IO computation io to the returnIOM function, which wraps the value in a successful IOMaybe computation."
    },
    {
        "Statement": "fac :: Int -> Int",
        "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
    },
    {
        "Statement": "sum (x:xs) = x + sum xs",
        "Description": "Define the recursive case of the sum function where a non-empty list is given. It adds the first element 'x' to the result of recursively summing the rest of the list 'xs'."
    },
    {
        "Statement": "evalStateT :: Monad m => StateT s m a -> s -> m a",
        "Description": "Declare a function `evalStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the result value `a` (discarding the final state)."
    },
    {
        "Statement": "filterJust f = mapMaybe f",
        "Description": "The implementation of 'filterJust' simply applies the 'mapMaybe' function to the input function 'f' and the input list."
    },
    {
        "Statement": "insert y (x:xs)",
        "Description": "Define the recursive case of the insert function where a non-empty list is given. It inserts the element 'y' into the sorted list."
    },
    {
        "Statement": "toLowerString = map toLower",
        "Description": "Use the `map` function with `toLower` to convert each character in the input string to lowercase."
    },
    {
        "Statement": "splitAt :: Int -> Seq a -> (Seq a, Seq a)",
        "Description": "Declare a function splitAt that splits a sequence at a specified index."
    },
    {
        "Statement": "func :: Int -> Int",
        "Description": "Define a function named `func` which takes an `Int` and returns an `Int`."
    },
    {
        "Statement": "filter' p = foldl' (\\acc x -> if p x then acc ++ [x] else acc) []",
        "Description": "The implementation of 'filter'' uses 'foldl'' to fold the input list using an anonymous function that appends the current element 'x' to the accumulator 'acc' if 'p x' is 'True'. The initial accumulator is an empty list '[]'."
    },
    {
        "Statement": "maybe_val <- iom",
        "Description": "Bind the result of the first IOMaybe computation iom to the variable maybe_val."
    },
    {
        "Statement": "m>>n = m >>= \\_-> n",
        "Description": "Define the implementation of (>>) operator, which sequences two monadic computations. It applies the first computation m, discards its result using a lambda function, and then proceeds to execute the second computation n."
    },
    {
        "Statement": "Nothing -> return Nothing",
        "Description": "If maybe_val is Nothing, return a failed IOMaybe computation by returning Nothing."
    },
    {
        "Statement": "concat :: Seq (Seq a) -> Seq a",
        "Description": "Declare a function concat that concatenates a sequence of sequences into a single sequence."
    },
    {
        "Statement": "where edges = concatMap (\\(Node _ children) -> zip (repeat n) (map nodeIndex children)) (zip nodes [0..])",
        "Description": "Define a helper function to generate the list of edges, where each node is associated with its index, and edges are created from each node to its children."
    },
    {
        "Statement": "abbreviation sizeT :: \"'a Tree → nat\"",
        "Description": "Define an abbreviation named sizeT which takes a Tree of type 'a and returns a natural number."
    },
    {
        "Statement": "deleteBy eq y (x:xs)",
        "Description": "Define the recursive case of the deleteBy function where a non-empty list is given. It removes the first occurrence of the element 'y' that satisfies the predicate 'eq'."
    },
    {
        "Statement": "]",
        "Description": "End the list definition."
    },
    {
        "Statement": "(>>>=) = bindIOM",
        "Description": "Define the (>>>=) operator as bindIOM."
    },
    {
        "Statement": "newtype Reader r a = Reader { runReader :: r -> a }\n\ninstance Functor (Reader r) where\n    fmap f (Reader g) = Reader (f . g)\n\ninstance Applicative (Reader r) where\n    pure x = Reader $ \\_ -> x\n    Reader f <*> Reader g = Reader $ \\x -> f x (g x)\n\ninstance Monad (Reader r) where\n    return = pure\n    Reader f >>= k = Reader $ \\r -> runReader (k (f r)) r",
        "Description": "Define a newtype 'Reader' with parameters 'r' and 'a'. Provide instances of the 'Functor', 'Applicative', and 'Monad' type classes for the 'Reader' newtype, allowing for mapping, applying, and sequencing computations that depend on an environment of type 'r'."
    },
    {
        "Statement": "toLowerCase = map toLower",
        "Description": "The implementation of 'toLowerCase' applies the 'toLower' function to each character in the input string using the 'map' function."
    },
    {
        "Statement": "if input == ending then",
        "Description": "Check if the input string is equal to the ending string."
    },
    {
        "Statement": "con \"multiply\" ((*) :: Int -> Int -> Int),",
        "Description": "Include the 'multiply' function signature."
    },
    {
        "Statement": "quicksort :: Ord a => [a] -> [a]",
        "Description": "Define a function 'quicksort' that takes a list of elements of any type 'a' that implements the 'Ord' typeclass, and returns a sorted list of the same type."
    },
    {
        "Statement": "unzip :: [(a, b)] -> ([a], [b])",
        "Description": "Define 'unzip' as a function which takes a list of pairs and returns a pair of lists."
    },
    {
        "Statement": "guard (checkInput input)",
        "Description": "Use the `guard` function to conditionally proceed with the computation based on the result of `checkInput input`, which presumably checks if the input satisfies some condition."
    },
    {
        "Statement": "map :: (a -> b) -> [a] -> [b]",
        "Description": "Define a function named `map` which takes a function `(a -> b)` and a list of `a` and returns a list of `b`."
    },
    {
        "Statement": "count <- get",
        "Description": "Retrieve the current count value from the state using the `get` function."
    },
    {
        "Statement": "\"shows 'sorted (inorder l @ [v] @ inorder r)'\"",
        "Description": "Show that the inorder traversal of l, followed by v, followed by the inorder traversal of r, is sorted."
    },
    {
        "Statement": "    | otherwise = x:xs",
        "Description": "Define the condition for the recursive case of the dropWhile function. If the predicate 'p' does not hold true for the current element 'x', it returns the list starting from 'x'."
    },
    {
        "Statement": "elemIndexL :: Eq a => a -> Seq a -> Maybe Int",
        "Description": "Declare a function elemIndexL that returns the index of the first occurrence of an element in a sequence."
    },
    {
        "Statement": "Class Num a where",
        "Description": "Declare a typeclass 'Num' which represents numeric types."
    },
    {
        "Statement": "map2D x = (\\xs -> map (\\ys -> map x ys) xs)",
        "Description": "Define 'map2D' as a function taking an argument 'x' and returning a function that maps 'x' over each element of a list of lists."
    },
    {
        "Statement": "where aux ending count = do",
        "Description": "Begin the definition of the `aux` function using the do notation for monadic computations. The `aux` function takes the `ending` string and the current `count` as arguments."
    },
    {
        "Statement": "where",
        "Description": "Begin definition of the `sortedT` abbreviation."
    },
    {
        "Statement": "    | y <= x = y : x : xs",
        "Description": "Define the condition for the recursive case of the insert function. If the element 'y' is less than or equal to the current element 'x', it inserts 'y' before 'x'."
    },
    {
        "Statement": "maybeadd Nothing (Just 1)",
        "Description": "Applly `maybeadd` function with `Nothing` and `Just 1`, resulting in Nothing."
    },
    {
        "Statement": "minInts = foldl' min (maxBound :: Int)",
        "Description": "The implementation of 'minInts' uses 'foldl'' to fold the input list of integers using the 'min' function and an initial accumulator value of 'maxBound :: Int' (the largest possible integer value)."
    },
    {
        "Statement": "int func(int arg) {",
        "Description": "Start the definition of a function named 'func' that takes an integer argument 'arg'."
    },
    {
        "Statement": "map2D = map . map",
        "Description": "Define 'map2D' as the composition of 'map' function applied twice."
    },
    {
        "Statement": "import Data.List (foldl')\n\nor' :: [Bool] -> Bool",
        "Description": "Define a function 'or'' that takes a list of boolean values and returns their logical disjunction (OR). Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "m = frequencies xs",
        "Description": "Define 'm' as the map of frequencies for the remaining elements."
    },
    {
        "Statement": "con \"odd\" (odd :: Int -> Bool),",
        "Description": "Include the 'odd' function signature."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the auto tactic to automatically solve the generated subgoals."
    },
    {
        "Statement": "quicksort :: Ord a => [a] -> [a]",
        "Description": "Define a function 'quicksort' that takes a list of elements of type 'a' (which must be an instance of the 'Ord' typeclass) and returns a sorted list."
    },
    {
        "Statement": "transpose :: [[a]] -> [[a]]",
        "Description": "Define 'transpose' as a function which transposes the rows and columns of a list of lists."
    },
    {
        "Statement": "background [ prelude ]",
        "Description": "Include the Prelude module in the background."
    },
    {
        "Statement": "proof (induction xs)",
        "Description": "Apply induction on the list."
    },
    {
        "Statement": "sum = foldr (+) 0",
        "Description": "Calculate the sum of a list of numbers using a right fold (foldr) with the addition operator (+) and starting with an initial accumulator value of 0."
    },
    {
        "Statement": "concatMap :: (a -> Seq b) -> Seq a -> Seq b",
        "Description": "Declare a function concatMap that maps a function over a sequence and concatenates the results."
    },
    {
        "Statement": "proof (induction xs)",
        "Description": "Apply induction on the first list."
    },
    {
        "Statement": "let ncount = count + 1",
        "Description": "Calculate the new count by incrementing the current count by 1, and bind it to the variable ncount."
    },
    {
        "Statement": "guard :: Alternative f => Bool -> f ()\nguard True  = pure ()\nguard False = empty",
        "Description": "Define a function 'guard' that takes a boolean value and returns an empty structure if the value is false, otherwise returns a structure containing a unit value, using the 'Alternative' operations."
    },
    {
        "Statement": "fromList :: [a] -> Set a",
        "Description": "Declare a function fromList that takes a list and returns a set."
    },
    {
        "Statement": "instance Semigroup [a]",
        "Description": "Provide an instance of Semigroup for lists, where the (<>) operation is defined as list concatenation (++)."
    },
    {
        "Statement": "lemma insert_sorted:",
        "Description": "Define a lemma named insert_sorted."
    },
    {
        "Statement": "(==) (F n) (F m) = n == m",
        "Description": "Define the equality operator '==' for comparing two temperatures in Fahrenheit. It returns true if their values are equal."
    },
    {
        "Statement": "then returnIOM input",
        "Description": "If the input is valid, return a successful IOMaybe computation with the input String."
    },
    {
        "Statement": "    | otherwise = deleteFirstsBy eq (deleteBy eq y xs) ys",
        "Description": "Define the condition for the recursive case of the deleteFirstsBy function. It removes the first occurrence of the current element 'y' from the first list using the predicate 'eq', and then recursively processes the rest of the second list."
    },
    {
        "Statement": "Lemma sorted node:",
        "Description": "Define a lemma named `sorted_node`."
    },
    {
        "Statement": "sortBy :: (a -> a -> Ordering) -> [a] -> [a]",
        "Description": "Define 'sortBy' as a function which sorts a list by the given comparison function."
    },
    {
        "Statement": "elemIndicesL :: Eq a => a -> Seq a -> Seq Int",
        "Description": "Declare a function elemIndicesL that returns all indices of occurrences of an element in a sequence."
    },
    {
        "Statement": "runState :: States a →>s -> (a, s)",
        "Description": "Declare a function runState that takes a State computation and an initial state, and returns a tuple containing the final result and the final state."
    },
    {
        "Statement": "instance ArrowApply (->) where\n  app (f, x) = f x\n\ninstance Monad m => ArrowApply (Kleisli m) where\n  app = Kleisli (\\(Kleisli f, x) -> f x)",
        "Description": "Provide instances of the 'ArrowApply' type class for the function type constructor '(->) a b' and the 'Kleisli' newtype, assuming that 'm' is an instance of the 'Monad' type class."
    },
    {
        "Statement": "(>>) :: Monad m => m a -> m b -> m b",
        "Description": "Define the (>>) operator for any monad, taking two monadic values of types m a and m b respectively, and producing a monadic value of type m b."
    },
    {
        "Statement": "Nil >>= _ = Nil",
        "Description": "If the input to the bind operation is Nil, return Nil."
    },
    {
        "Statement": "import Data. List hiding ( insert )",
        "Description": "Import the Data.List module and hide the 'insert' function."
    },
    {
        "Statement": "example = runMaybeT $ do",
        "Description": "Define a value `example` by running a `MaybeT` computation using `runMaybeT`."
    },
    {
        "Statement": "subsequences' = subsequences",
        "Description": "The implementation of 'subsequences'' simply applies the 'subsequences' function to the input list."
    },
    {
        "Statement": "con \":\" ((:) :: A -> [A] -> [A])",
        "Description": "Declare the signature for ':' function."
    },
    {
        "Statement": "map [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "bSort (x:xs) acc = bSort xs (bubbleUp x acc)",
        "Description": "Otherwise, recursively call bSort with the tail of the list and the result of bubbleUp with the head of the list and the accumulator."
    },
    {
        "Statement": "rseq :: Strategy a",
        "Description": "Create a Strategy that evaluates the given value to weak head normal form."
    },
    {
        "Statement": "greet :: Person -> String",
        "Description": "Define a function 'greet' which takes a 'Person' and returns a greeting string."
    },
    {
        "Statement": "splice [] ys = ys",
        "Description": "If the first list is empty, return the second list ys as the result of splicing."
    },
    {
        "Statement": "safeGetLine :: IO (Maybe String)",
        "Description": "Define a function safeGetLine that returns an IO action that produces a Maybe String."
    },
    {
        "Statement": "fac n = aux n 1 where aux n acc | n <= 1 = acc | otherwise = aux (n-1) (nacc)",
        "Description": "Define a function 'fac' that calculates the factorial of 'n' using an accumulator. It initializes the accumulator to 1 and calls the auxiliary function 'aux' with 'n' and the accumulator. The 'aux' function recursively calculates the factorial by updating 'n' and 'acc' until 'n' becomes less than or equal to 1, at which point it returns the accumulator."
    },
    {
        "Statement": "where",
        "Description": "Begin the definition of helper functions for 'words'."
    },
    {
        "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
        "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
    },
    {
        "Statement": "preOrder :: Tree a -> [a]",
        "Description": "Define a function named preOrder which takes a Tree of elements of type a and returns a list of the elements in pre-order traversal order."
    },
    {
        "Statement": "instance ArrowApply (->) where",
        "Description": "Create an instance of the ArrowApply typeclass for the function type constructor (->) that represents functions."
    },
    {
        "Statement": "con \":@\" ((++) :: [a] -> [a] -> [a]),",
        "Description": "Include the ':@' operator signature."
    },
    {
        "Statement": "checkInput [] = False",
        "Description": "If the input String is empty, return False."
    },
    {
        "Statement": "(1,2) :: (Int, Int)",
        "Description": "Represent a tuple containing two integers."
    },
    {
        "Statement": "snd (,y) = y",
        "Description": "Define the function 'snd' which extracts the second element of a tuple."
    },
    {
        "Statement": "import Data.Char (isSpace, toLower)",
        "Description": "Import the 'isSpace' and 'toLower' functions from the Data.Char module."
    },
    {
        "Statement": "elem :: Eq a => a -> Seq a -> Bool",
        "Description": "Declare a function elem that checks if an element is in a sequence."
    },
    {
        "Statement": "app :: (a -> b) -> a->b",
        "Description": "Define a higher-order function 'app' that takes a function 'f' and a value 'x' as arguments, and applies 'f' to 'x'."
    },
    {
        "Statement": "greet Hello",
        "Description": "Define a function 'greet' that takes a string argument and prints 'Hello user' with the argument appended."
    },
    {
        "Statement": "- )",
        "Description": "End of the comment."
    },
    {
        "Statement": "sortList xs = sort xs",
        "Description": "The implementation of 'sortList' simply applies the 'sort' function to the input list 'xs'."
    },
    {
        "Statement": "insert x [] = [x]",
        "Description": "If the input list is empty, return a singleton list containing x."
    },
    {
        "Statement": "zipWith _ _ [] = []",
        "Description": "Define the case of the zipWith function where the second list is empty, it returns an empty list."
    },
    {
        "Statement": "| otherwise = elem y xs",
        "Description": "Otherwise, check the rest of the list."
    },
    {
        "Statement": "showsPrec :: Int -> a -> ShowS",
        "Description": "Define a function 'showsPrec' within the 'Show' typeclass which takes an integer and a value of type 'a', and returns a 'ShowS' function."
    },
    {
        "Statement": "n == 0 =1",
        "Description": "If `n` is equal to 0, return 1."
    },
    {
        "Statement": "con \":<\" ((<) :: Int -> Int -> Bool),",
        "Description": "Include the ':<' operator signature."
    },
    {
        "Statement": "newtype Product a = Product { getProduct :: a }",
        "Description": "Define a new data type called 'Product' with a single constructor 'Product' that wraps a value of type 'a'. The 'getProduct' function extracts the value of type 'a' from the 'Product' constructor."
    },
    {
        "Statement": "length (_:xs) = 1 + length xs",
        "Description": "Define the length of a non-empty list as 1 plus the length of the remaining elements (xs)."
    },
    {
        "Statement": "readUntil ending = do",
        "Description": "Begin the definition of the `readUntil` function using the do notation for monadic computations."
    },
    {
        "Statement": "data MyError = ErrorA | ErrorB deriving Show",
        "Description": "Define a data type MyError with two constructors ErrorA and ErrorB, and derive the Show instance for it."
    },
    {
        "Statement": "bubbleUp x (y:ys) | otherwise = x : y : ys",
        "Description": "Otherwise, prepend x and the head of the accumulator to the tail of the accumulator."
    },
    {
        "Statement": "exitSuccess :: IO a",
        "Description": "Define a function 'exitSuccess' which performs an IO action that terminates the program with a success status."
    },
    {
        "Statement": "foldr1 f (x:xs) = foldr f x xs",
        "Description": "Define 'foldr1' as a function that applies a binary function in a right-associative manner to the elements of a non-empty list, using the first element as the starting value."
    },
    {
        "Statement": "name arg1 arg2 ... argn",
        "Description": "Calls the function 'name' with 'n' arguments."
    },
    {
        "Statement": "lookup :: Eq a => a -> [(a, b)] -> Maybe b",
        "Description": "Define 'lookup' as a function which finds the first value associated with the given key in the list of key-value pairs."
    },
    {
        "Statement": "append Nil ys = ys",
        "Description": "If the first input list is Nil, return the second list."
    },
    {
        "Statement": "\"sortedT t ⟶ sorted (inorder t)\"",
        "Description": "If the tree t is sorted, then the inorder traversal of t is also sorted."
    },
    {
        "Statement": "returnIOM :: a -> IOMaybe a",
        "Description": "Define a function returnIOM that takes a value of type a and returns a successful IOMaybe computation with that value."
    },
    {
        "Statement": "flip' :: (a -> b -> c) -> b -> a -> c",
        "Description": "Define a function flip' that takes a function f and two arguments a and b, and returns the result of applying f to b and a (flipping the order of the arguments)."
    },
    {
        "Statement": "[2*x | x <- [1,2,3], x>1 ]",
        "Description": "Generate a list where each element is obtained by doubling each element of the list [1,2,3], but only if the element is greater than 1."
    },
    {
        "Statement": "reverseString :: String -> String",
        "Description": "Define a function reverseString that takes a String and reverses it."
    },
    {
        "Statement": "where",
        "Description": "Begin the definition of helper functions for 'trim'."
    },
    {
        "Statement": "safeHead (x:_) = Just x",
        "Description": "For a non-empty list, 'safeHead' returns the first element wrapped in a 'Just' value."
    },
    {
        "Statement": "type IOMaybe a = IO (Maybe a)",
        "Description": "Define a new type synonym IOMaybe a that represents a computation that can perform side effects and either succeed with a value of type a or fail without a value."
    },
    {
        "Statement": "monoTypeWithVars [\"t\", \"t1\", \"t2\"] (Proxy :: Proxy (Tree OrdA)),",
        "Description": "Include the type proxy 'Tree OrdA' in 'treesig2' with type variables 't', 't1', and 't2'."
    },
    {
        "Statement": "(+) :: a -> a -> a",
        "Description": "Define the addition operation '+' within the 'Num' typeclass which takes two values of type 'a' and returns a value of type 'a'."
    },
    {
        "Statement": "case Nil",
        "Description": "If the case is an empty list."
    },
    {
        "Statement": "(+) :: Num a => a -> a -> a",
        "Description": "Define an operator '+' which takes two arguments of type 'a' belonging to the 'Num' typeclass and returns a value of the same type."
    },
    {
        "Statement": "splitWords = filter (not . null) . map (filter (not . isSpace)) . groupBy ((==) on isSpace)",
        "Description": "The implementation of 'splitWords' uses a pipeline of functions: first, group the characters in the input string into lists based on whether they are whitespace or not using 'groupBy' and the 'isSpace' predicate; then, for each group, filter out the whitespace characters using 'filter' and 'isSpace'; finally, remove any empty strings from the resulting list of words using 'filter' and 'null'."
    },
    {
        "Statement": "nub' :: Eq a => [a] -> [a]",
        "Description": "Define a function nub' that takes a list xs and removes duplicate elements from xs, preserving the order of the remaining elements."
    },
    {
        "Statement": "quicksort (x:xs) = quicksort [y | y <- xs, y < x] ++ [x] ++ quicksort [y | y <- xs, y >= x]",
        "Description": "For a non-empty list, 'quicksort' selects a pivot element 'x', partitions the remaining elements into two lists (elements less than 'x' and elements greater than or equal to 'x'), recursively sorts the two lists, and concatenates the sorted lists with the pivot element in the middle."
    },
    {
        "Statement": "quicksort (x:xs) = quicksort [y | y <- xs, y <= x] ++ [x] ++ quicksort [y | y <- xs, y > x]",
        "Description": "Otherwise, sort the list using the quicksort algorithm."
    },
    {
        "Statement": "getName :: IOMaybe String",
        "Description": "Define a function getName that returns an IOMaybe String."
    },
    {
        "Statement": "monoTypeWithVars [\"t\", \"t1\", \"t2\"] (Proxy :: Proxy (Tree Int)),",
        "Description": "Include the type proxy 'Tree Int' in 'treesig2' with type variables 't', 't1', and 't2'."
    },
    {
        "Statement": "if input == ending then return ncount else aux ending ncount",
        "Description": "Check if the input is equal to the `ending` string. If so, return the current `ncount` value. Otherwise, recursively call `aux` with the same `ending` string and the updated `ncount` value."
    },
    {
        "Statement": "merge xs [] = xs",
        "Description": "If the second list is empty, 'merge' returns the first list."
    },
    {
        "Statement": "con \"minimum\" (minimum :: [Int] -> Int),",
        "Description": "Include the 'minimum' function signature."
    },
    {
        "Statement": "fun insert v Leaf = Node Leaf v Leaf",
        "Description": "If the tree is empty, insert `v` and create a node."
    },
    {
        "Statement": "next",
        "Description": "Move to the next case."
    },
    {
        "Statement": "elemIndex :: Eq a => a -> [a] -> Maybe Int",
        "Description": "Define 'elemIndex' as a function which returns the index of the first occurrence of the given element in the list."
    },
    {
        "Statement": "maybeadd (Just 2) (Just 1)",
        "Description": "Applly `maybeadd` function with `Just 2` and `Just 1`, resulting in Just 3."
    },
    {
        "Statement": "import Data.Char (isLower)\n\nuncapitalize :: String -> String",
        "Description": "Define a function 'uncapitalize' that takes a string and returns a new string with the first character converted to lowercase (if it is a letter) and the remaining characters unchanged. Import the 'isLower' function from the 'Data.Char' module."
    },
    {
        "Statement": "fromMaybe :: a -> Maybe a  -> a",
        "Description": "Define a function 'fromMaybe' which takes a default value and a 'Maybe' value. If the 'Maybe' value is 'Just', it returns the contained value, otherwise it returns the default value."
    },
    {
        "Statement": "returnIOM = return . Just",
        "Description": "Implement the returnIOM function by composing the Just constructor with the return function from the Monad typeclass."
    },
    {
        "Statement": "greet (Person n_) = \"Hi\" ++ n_",
        "Description": "Define 'greet' function pattern matching on 'Person' constructor with 'n_' as its argument, concatenating \"Hi\" with 'n_'."
    },
    {
        "Statement": "datatype 'a Tree = Leaf | Node \"'a Tree\" 'a \"'a Tree\"",
        "Description": "Define a datatype named `Tree` that takes a type parameter `'a`."
    },
    {
        "Statement": "import Data.Maybe (mapMaybe)\n\nfilterJust :: (a -> Maybe b) -> [a] -> [b]",
        "Description": "Define a function 'filterJust' that takes a function from 'a' to 'Maybe b' and a list of 'a' values, and returns a list containing only the 'Just' values resulting from applying the function to each element of the input list. Import the 'mapMaybe' function from the 'Data.Maybe' module."
    },
    {
        "Statement": "(Just v) -> f v",
        "Description": "If maybe_val is Just v, apply the function f to the value v and return the resulting IOMaybe computation."
    },
    {
        "Statement": "elem :: Eq a => a -> [a] -> Bool",
        "Description": "Define a function named `elem` which takes an element of type `a` and a list of type `[a]` and returns a `Bool`."
    },
    {
        "Statement": "put :: s -> m ()",
        "Description": "Declare a function put that takes a new state and updates the current state inside a monadic context, returning an empty tuple."
    },
    {
        "Statement": "by auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "getInput :: IO String",
        "Description": "Define a function getInput that returns an IO action that produces a String."
    },
    {
        "Statement": "fun inorder :: \"'a Tree → 'a list\"",
        "Description": "Define a function named `inorder` which takes a `Tree 'a` and returns a list of 'a."
    },
    {
        "Statement": "case (1 v)",
        "Description": "If the case is (1 v),"
    },
    {
        "Statement": "input <- getLine",
        "Description": "Get a line of input from the user using the getLine function from the IO monad."
    },
    {
        "Statement": "func :: Int -> Int -> Int -> Int",
        "Description": "Define a function named `func` which takes three `Int` parameters and returns an `Int`."
    },
    {
        "Statement": "transposeMatrix = transpose",
        "Description": "The implementation of 'transposeMatrix' simply applies the 'transpose' function, which transposes the input matrix."
    },
    {
        "Statement": "lift3 f x y = lift2 f x y",
        "Description": "Define the 'lift3' function by applying 'lift2' to the input function 'f' and the input values 'x' and 'y' of type 'f a'."
    },
    {
        "Statement": "mapA :: ArrowChoice a => a a1 a2 -> a [a1] [a2]\nmapA f =\n  arr listCase >>>\n  arr (const []) ||| (f *** mapA f >>> arr (uncurry (:)))",
        "Description": "Define a function 'mapA' that takes an arrow 'f' and applies it to each element of a list. It uses the 'ArrowChoice' operations to implement map in a point-free style."
    },
    {
        "Statement": "[ (x,y) | x <- [1,2,3], y <- ['a','b']]",
        "Description": "Generate a list of tuples where each tuple contains an element from the list [1,2,3] paired with each element from the list ['a','b']."
    },
    {
        "Statement": "count :: Int -> Int -> IO ()",
        "Description": "Declares a function 'count' that takes two integers and performs IO actions."
    },
    {
        "Statement": "Space c = f acc cs",
        "Description": "If the current character is not whitespace, 'f' recursively processes the remaining characters with the current character prepended to the accumulator."
    },
    {
        "Statement": "newtype Sum a = Sum { getSum :: a }\nderiving (Eq, Ord, ..... )",
        "Description": "Define a new data type Sum that wraps a value of type a, and derives various type class instances for it, such as Eq, Ord, etc."
    },
    {
        "Statement": "insert x (y:ys) | otherwise = y : insert x ys",
        "Description": "Otherwise, prepend the head of the list to the result of recursively calling insert with x and the tail of the list."
    },
    {
        "Statement": "lift2 :: ( a -> b -> c ) -> (f a -> f b -> f c )",
        "Description": "Declare the 'lift2' function signature, which takes a binary function '(a -> b -> c)' and returns a function that lifts the binary function to operate on values of types 'f a' and 'f b', returning a value of type 'f c'."
    },
    {
        "Statement": "(<>) (NonEmpty (x, xs)) (NonEmpty (y, ys)) = NonEmpty (x, xs ++ [y] ++ ys)",
        "Description": "Define the '<>' operator for the 'Semigroup' instance of 'NonEmpty a' to concatenate two 'NonEmpty' lists."
    },
    {
        "Statement": "getName :: IOMaybe String",
        "Description": "Define a function getName that represents an IOMaybe computation that can get a valid name from the user."
    },
    {
        "Statement": "aux acc\n(x:xs) = aux (x:acc) xs",
        "Description": "Otherwise, prepend the current element to the accumulator and continue."
    },
    {
        "Statement": "instance Monad ((->) r)",
        "Description": "Create an instance of the Monad typeclass for the function type constructor (->) r, which represents computations that take a value of type r as input and return a value of type a."
    },
    {
        "Statement": "f = reverse . sort",
        "Description": "Define f as a composition of reverse and sort functions."
    },
    {
        "Statement": "p n= n≥ 0",
        "Description": "Define `p` as a function that takes `n` and returns `True` if `n` is greater than or equal to 0."
    },
    {
        "Statement": "Lemma sets value sortedT:",
        "Description": "Define a lemma named `sortedT_values`."
    },
    {
        "Statement": "instance Monoid (All a) where",
        "Description": "Define a 'Monoid' instance for the 'All' data type."
    },
    {
        "Statement": "f :: Int -> Int -> IO ()\nf a b = do\n  let x = a+b\n  putStrLn $! show x",
        "Description": "Define a function f that takes two integers a and b, computes their sum x, and prints the value of x using putStrLn."
    },
    {
        "Statement": "delete w = arr words >>> arr (filter (/= w)) >>> arr unwords",
        "Description": "Define a function delete that takes a word w and returns a new function that removes all occurrences of w from a given string, using the point-free style and the arr function from the Arrow typeclass."
    },
    {
        "Statement": "insert :: Ord a => a -> [a] -> [a]",
        "Description": "Define 'insert' as a function which inserts an element into a sorted list, keeping it sorted."
    },
    {
        "Statement": "if checkInput input",
        "Description": "Check if the input is valid using the checkInput function."
    },
    {
        "Statement": "mempty = Any False",
        "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Any a' as an 'Any' value wrapping 'False'."
    },
    {
        "Statement": "type State s = StateT s Identity",
        "Description": "Declare a type alias State s, which is equivalent to StateT s Identity, representing a state monad transformer with the Identity monad."
    },
    {
        "Statement": "};",
        "Description": "End of the class definition."
    },
    {
        "Statement": "case False",
        "Description": "If the case is False,"
    },
    {
        "Statement": "fac :: Int -> Int",
        "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
    },
    {
        "Statement": "reverse :: [a] -> [a]",
        "Description": "Define a function named `reverse` which takes a list of any type and returns a list of the same type."
    },
    {
        "Statement": "import Data.Char (toUpper)",
        "Description": "Import the 'toUpper' function from the Data.Char module, which converts a character to its uppercase equivalent."
    },
    {
        "Statement": "append Nil ys = ys",
        "Description": "If the first input list is Nil, return the second list."
    },
    {
        "Statement": "splice xs [] = xs",
        "Description": "Define the splice function for a non-empty list xs and an empty list to return the list xs."
    },
    {
        "Statement": "case (Cons x xs)",
        "Description": "If the case is a non-empty list."
    },
    {
        "Statement": "| otherwise = func (x-y) (y*2) (z+1)",
        "Description": "Otherwise, recursively call `func` with `(x-y)`, `(y*2)`, and `(z+1)`."
    },
    {
        "Statement": "data List a = Nil | Cons a (List a)",
        "Description": "Define a data type named List which is either Nil or a Cons cell containing an element of type a and a List of the same type."
    },
    {
        "Statement": "(==) (C c) (F f) = (1.8c + 32) == f",
        "Description": "Define the equality operator '==' for comparing a temperature in Celsius with a temperature in Fahrenheit. It returns true if the Celsius temperature, when converted to Fahrenheit, is equal to the given Fahrenheit temperature."
    },
    {
        "Statement": "height :: Tree a -> Int",
        "Description": "Define a function named height which takes a Tree of elements of type a and returns the height of the tree as an Int."
    },
    {
        "Statement": "y = func2 arg",
        "Description": "Define a variable 'y' which is assigned the result of calling function 'func2' with argument 'arg'."
    },
    {
        "Statement": "fst (x,) = x",
        "Description": "Define the function 'fst' which extracts the first element of a tuple."
    },
    {
        "Statement": "elem y (x:xs)",
        "Description": "If `y` is in the list, return `True`. Otherwise, check the rest of the list."
    },
    {
        "Statement": "concat' = foldl' (++) []",
        "Description": "The implementation of 'concat'' uses 'foldl'' to fold the input list of lists using the '++' operator (list concatenation) and an initial accumulator value of an empty list '[]'."
    },
    {
        "Statement": "import Module hiding (name1, name2)",
        "Description": "Imports all entities from the module 'Module' into the current namespace except for 'name1' and 'name2'."
    },
    {
        "Statement": "dropWhile _ [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "returnIOM = return . Just",
        "Description": "Implement the returnIOM function by composing the Just constructor with the return function from the Monad typeclass."
    },
    {
        "Statement": "maybe_val <- iom",
        "Description": "Bind the result of evaluating iom to maybe_val."
    },
    {
        "Statement": "delete w = arr words >>> arr (filter (/= w)) >>> arr unwords",
        "Description": "Define a function delete that takes a word w and returns a new function that removes all occurrences of w from a given string, using the point-free style and the arr function from the Arrow typeclass."
    },
    {
        "Statement": "zip (a:as) (b:bs) = (a,b) : zip as bs",
        "Description": "Define the recursive case of the zip function where two non-empty lists are given. It combines the first element of each list into a tuple and then recursively does the same for the rest of the lists."
    },
    {
        "Statement": "any :: (a -> Bool) -> Seq a -> Bool",
        "Description": "Declare a function any that checks if any element of a sequence satisfies a predicate."
    },
    {
        "Statement": "isPrefixOf [] _ = True",
        "Description": "Define the case of the isPrefixOf function where the first list is empty, it returns True."
    },
    {
        "Statement": "evalStateT :: Monad m => StateT s m a -> s -> m a",
        "Description": "Declare a function `evalStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the result value `a` (discarding the final state)."
    },
    {
        "Statement": "name <- getLine",
        "Description": "Read a line of input from the user and bind it to name."
    },
    {
        "Statement": "\"∀t1 t2. sortedT t1 ⟶ sortedT t2 ⟶ t1 ⊆ t2 ⟶ sortedT t1\"",
        "Description": "For all trees t1 and t2, if t1 and t2 are sorted and t1 is a subset of t2, then t1 is also sorted."
    },
    {
        "Statement": "map f = foldr ((:) . f) []",
        "Description": "Define 'map' as a fold operation that applies function 'f' to each element of the list and constructs a new list."
    },
    {
        "Statement": "merge [] ys = ys",
        "Description": "If the first list is empty, 'merge' returns the second list."
    },
    {
        "Statement": "(==)  _ _ = False",
        "Description": "Define a catch-all case for the equality operator '==' which returns false for any other combination of temperatures."
    },
    {
        "Statement": "findIndexL :: (a -> Bool) -> Seq a -> Maybe Int",
        "Description": "Declare a function findIndexL that returns the index of the first element satisfying a predicate in a sequence."
    },
    {
        "Statement": "(<$) :: a -> f b -> f a",
        "Description": "Declare the '(<$)' operator signature for the 'Functor' type class, which takes a value of type 'a' and a value of type 'f b', and returns a value of type 'f a'."
    },
    {
        "Statement": "in_range min max x =",
        "Description": "Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x'."
    },
    {
        "Statement": "any' :: (a -> Bool) -> [a] -> Bool",
        "Description": "Define a function any' that takes a predicate p and a list xs, and returns True if at least one element of xs satisfies the predicate p, otherwise False."
    },
    {
        "Statement": "null :: [a] -> Bool",
        "Description": "Return True if a list is empty, otherwise False."
    },
    {
        "Statement": "\"(Vlv € setT l. lv ≤ v)\"",
        "Description": "Assume that for every lv in the set of l, lv is less than or equal to v."
    },
    {
        "Statement": "exitWith code = System.Exit.exitWith code",
        "Description": "Implement the 'exitWith' function using 'System.Exit.exitWith'."
    },
    {
        "Statement": "instance Monoidal [] where",
        "Description": "Define a 'Monoidal' instance for the list type constructor '[]'."
    },
    {
        "Statement": "Lemma sortedT_values sets: \"sortedT t A t = (Node l v r) → (Vv € setT l. lv ≤ v) A (Vrv e setT r. rv 2 v)\"",
        "Description": "Define a lemma asserting that if the tree t is sorted, then the left and right subtrees are also sorted."
    },
    {
        "Statement": "execStateT :: Monad m => StateT s m a -> s -> m s",
        "Description": "Declare a function `execStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the final state `s` (discarding the result value)."
    },
    {
        "Statement": "case (Cons x xs)",
        "Description": "If the case is a non-empty list."
    },
    {
        "Statement": "hn = n",
        "Description": "Assign `hn` the value of `n`."
    },
    {
        "Statement": "liftIOm io :: io >>= retrunIOM",
        "Description": "Implement the liftIOm function by binding the result of the IO computation io to the returnIOM function, which wraps the value in a successful IOMaybe computation."
    },
    {
        "Statement": "safeHeadOr x xs = fromMaybe x (safeHead xs)",
        "Description": "Define 'safeHeadOr' using the 'fromMaybe' function, which returns the value wrapped in the 'Maybe' value if it is 'Just x', or the default value 'x' if it is 'Nothing'."
    },
    {
        "Statement": "| otherwise = n * fac (n-1)",
        "Description": "Otherwise, return `n * fac (n-1)`."
    },
    {
        "Statement": "quickSort :: Ord a => [a] -> [a]",
        "Description": "Define a function named quickSort which takes a list of elements of type a, where a is an instance of the Ord typeclass, and returns a sorted list of the same elements."
    },
    {
        "Statement": "difference :: Set a -> Set a -> Set a",
        "Description": "Declare a function difference that returns the difference between two sets."
    },
    {
        "Statement": "unzip [] = ([], [])",
        "Description": "Define the base case of the unzip function where an empty list is given, it returns a pair of empty lists."
    },
    {
        "Statement": "partition :: (a -> Bool) -> [a] -> ([a], [a])",
        "Description": "Define 'partition' as a function which takes a predicate and a list and returns a pair of lists: those elements which satisfy the predicate and those that do not."
    },
    {
        "Statement": "instance Monad Maybe where",
        "Description": "Define an instance of the Monad typeclass for the Maybe data type."
    },
    {
        "Statement": "permutations' :: [a] -> [[a]]",
        "Description": "Define a function permutations' that takes a list xs and returns a list of all possible permutations of xs."
    },
    {
        "Statement": "firstIndexOf x = elemIndex x",
        "Description": "The implementation of 'firstIndexOf' simply applies the 'elemIndex' function to the element 'x' and the input list."
    },
    {
        "Statement": "data Point = D2 {x :: Int, y :: Int} | D3 {x :: Int, y :: Int, z :: Int}",
        "Description": "Define a datatype 'Point' with two constructors: 'D2' taking 'x' and 'y' coordinates, and 'D3' taking 'x', 'y', and 'z' coordinates."
    },
    {
        "Statement": "input <- liftIO getLine",
        "Description": "Read a line of input from the user within the `IO` monad, lifted into the `StateT` monad using `liftIO`."
    },
    {
        "Statement": "splice [] [] = []",
        "Description": "The base case for splicing two empty lists, which returns an empty list."
    },
    {
        "Statement": "sortedSig - [\npredicate \"sorted\" (sorted :: [Int] -> Bool),",
        "Description": "Declare the signature for the 'sorted' function."
    },
    {
        "Statement": "putStr \"Please enter your name: \"",
        "Description": "Print the prompt \"Please enter your name: \" to the user."
    },
    {
        "Statement": "put :: s -> m ()",
        "Description": "Declare a function `put` that takes a new state value and updates the current state within the base monad `m`."
    },
    {
        "Statement": "filter (\\(x,y) -> x/=y) [(1,2), (2,2)]",
        "Description": "Filter the list of tuples [(1,2), (2,2)] using the predicate function ((x,y) -> x/=y), resulting in [(1,2)]."
    },
    {
        "Statement": "in_upper_bound = max >= x;",
        "Description": "Check if 'x' is less than or equal to 'max' and assign the result to 'in_upper_bound'."
    },
    {
        "Statement": "deriving (Eq, Ord)",
        "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'Any' data type."
    },
    {
        "Statement": "mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()",
        "Description": "Define 'mapM_' which maps each element of a structure to a monadic action, and evaluates these actions from left to right, discarding the results."
    },
    {
        "Statement": "input <- lift getLine",
        "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
    },
    {
        "Statement": "lift $ putStr \"Please enter your name: \"",
        "Description": "Print the prompt \"Please enter your name: \" to the user within the `IO` monad, using `lift` to lift the `IO` action into the `MaybeT` monad."
    },
    {
        "Statement": "insert x (y:ys) | x <= y = x : y : ys",
        "Description": "If x is less than or equal to the head of the list, prepend x and the head to the tail of the list."
    },
    {
        "Statement": "otherwise = n * fac (n-1)",
        "Description": "Otherwise, return `n * fac (n-1)`."
    },
    {
        "Statement": "pure :: Monoidal f => a -> f a\n\npure x = fmap (\\\\_ -> x) unit",
        "Description": "Define a function pure that takes a value x and a Monoidal functor f and returns a functor f x, using the fmap and unit functions from the Monoidal and Functor typeclasses."
    },
    {
        "Statement": "instance Monoid (Any a) where",
        "Description": "Define a 'Monoid' instance for the 'Any' data type."
    },
    {
        "Statement": "safeHead [] = Nothing",
        "Description": "For an empty list, 'safeHead' returns 'Nothing'."
    },
    {
        "Statement": "deriving (Eq, Ord)",
        "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'Last' data type."
    },
    {
        "Statement": "\"assumes 'sortedT r'\"",
        "Description": "Assume that r is sorted."
    },
    {
        "Statement": "data Calculation = Add Int Int | Sub Int Int | Mul Int Int | Div Int Int",
        "Description": "Define a datatype 'Calculation' with constructors 'Add', 'Sub', 'Mul', and 'Div', each taking two 'Int' arguments."
    },
    {
        "Statement": "con \"isElement\" (elem :: Eq a => a -> [a] -> Bool),",
        "Description": "Include the 'isElement' function signature."
    },
    {
        "Statement": "input <- liftIo getLine",
        "Description": "Read a line of input from the user and bind it to the variable input, using liftIo to lift the IO action into the StateT monad."
    },
    {
        "Statement": "    where (ys, zs) = partition p xs",
        "Description": "Define the recursive case of the partition function. It separates the rest of the list into two lists."
    },
    {
        "Statement": "case (1 v)",
        "Description": "If the case is (1 v),"
    },
    {
        "Statement": "calc (Sub x y) = x-y",
        "Description": "Define the 'calc' function pattern matching on the 'Sub' constructor, returning the difference of 'x' and 'y'."
    },
    {
        "Statement": "import Data.Maybe (fromMaybe)",
        "Description": "Import the 'fromMaybe' function from the Data.Maybe module."
    },
    {
        "Statement": "newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}",
        "Description": "Define a new type 'Kleisli' parameterized by 'm', 'a', and 'b'. 'Kleisli' is a newtype wrapper around a function 'a -> m b', where 'm' is a monad."
    },
    {
        "Statement": "filter :: (a -> Bool) -> [a] -> [a]",
        "Description": "Define a function 'filter' that takes a predicate function 'f' and a list 'xs' as arguments, and returns a list containing only the elements of 'xs' for which 'f' returns True."
    },
    {
        "Statement": "app f x = f x",
        "Description": "Implement the 'app' function by applying the function 'f' to the value 'x'."
    },
    {
        "Statement": "main = do catch failing (\\(e :: MyError) -> do putStrLn \"Something went wrong!\")",
        "Description": "Define the main function to catch any exceptions of type MyError thrown by failing, and print a message \"Something went wrong!\" if an exception is caught. The handler function is explicitly typed to match the MyError type."
    },
    {
        "Statement": "sum (splice xs ys) =?= sum xs + sum ys",
        "Description": "Verify whether the sum of splicing two lists xs and ys is equal to the sum of the individual lists xs and ys."
    },
    {
        "Statement": "| n == 0      =1",
        "Description": "If `n` is equal to 0, return 1."
    },
    {
        "Statement": "by auto",
        "Description": "Use the auto tactic to automatically solve the generated subgoals."
    },
    {
        "Statement": "unwords [] = \"\"",
        "Description": "Define the base case of the unwords function where an empty list is given, it returns an empty string."
    },
    {
        "Statement": "calc (Sub x y) = x-y",
        "Description": "Define the 'calc' function pattern matching on the 'Sub' constructor, returning the difference of 'x' and 'y'."
    },
    {
        "Statement": "intersperse sep (x:xs) = x : concat [[sep, y] | y <- xs]",
        "Description": "Define the recursive case of the intersperse function where a non-empty list is given. It intersperses the separator 'sep' between each pair of elements in the list."
    },
    {
        "Statement": "failing = do throw Error",
        "Description": "Define the failing function to throw an exception of type Error."
    },
    {
        "Statement": "instance Semigroup (Any a) where",
        "Description": "Define a 'Semigroup' instance for the 'Any' data type."
    },
    {
        "Statement": "zip :: Seq a -> Seq b -> Seq (a, b)",
        "Description": "Declare a function zip that combines two sequences into a sequence of pairs."
    },
    {
        "Statement": "concatMapSig - [\ncon \"map\" (map :: (a -> b) →› [A] -> (B]),",
        "Description": "Declare the signature for 'map' function."
    },
    {
        "Statement": "indicesOf x = elemIndices x",
        "Description": "The implementation of 'indicesOf' simply applies the 'elemIndices' function to the element 'x' and the input list."
    },
    {
        "Statement": "mergeSort [x] = [x]",
        "Description": "For a list with a single element, 'mergeSort' returns the same list."
    },
    {
        "Statement": "con\n\"e\" (0 :: Int)\n]",
        "Description": "Declare the constant 'e' as '0' of type Int."
    },
    {
        "Statement": "append (Cons x xs) ys = Cons x (append xs ys)",
        "Description": "Otherwise, prepend the head of the first list to the result of recursively calling append with the tail of the first list and the second list."
    },
    {
        "Statement": "background [ prelude ]",
        "Description": "Include the Prelude module in the background."
    },
    {
        "Statement": "apply (induct t)",
        "Description": "Begin the proof by induction over tree t."
    },
    {
        "Statement": "map :: (a -> b) -> [a] -> [b]",
        "Description": "Define a function named `map` which takes a function `(a -> b)` and a list of `a` and returns a list of `b`."
    },
    {
        "Statement": "    | p x = Just x",
        "Description": "Define the condition for the recursive case of the find function. If the predicate 'p' is satisfied by the current element 'x', it returns Just x."
    },
    {
        "Statement": "con \"fromList\" (fromList :: [Orda] -› Tree Ord),",
        "Description": "Include the 'fromList' function signature in 'treeSig1'."
    },
    {
        "Statement": "                       _ : s'' -> lines s''",
        "Description": "Define the condition for the recursive case of the lines function. If the remaining string is not empty, it recursively processes the remaining string."
    },
    {
        "Statement": "data Either a b = Left a | Right b",
        "Description": "Define a data type 'Either' which represents a value of one of two possible types, 'a' or 'b', typically used for error handling where 'Left' indicates an error and 'Right' indicates a successful result."
    },
    {
        "Statement": "intersperse' :: a -> [a] -> [a]",
        "Description": "Define a function intersperse' that takes an element x and a list xs, and returns a new list where x is inserted between every pair of elements in xs."
    },
    {
        "Statement": "capitalize (x:xs) = if isUpper x then x:xs else toUpper x : xs",
        "Description": "If the first character 'x' of the input string is already uppercase, leave it unchanged and process the remaining characters 'xs'. Otherwise, convert 'x' to uppercase using 'toUpper' and prepend it to the remaining characters 'xs'."
    },
    {
        "Statement": "join :: (Monad m) => m (m a) -> m a\n\njoin x = x >>= id",
        "Description": "Define a function join that takes a nested monadic value m (m a) and flattens it to a single monadic value m a, using the (>>=) operator and the identity function id."
    },
    {
        "Statement": "fac n",
        "Description": "Define `fac` with parameter `n`."
    },
    {
        "Statement": "replicate :: Int -> a -> [a]",
        "Description": "Define a function named `replicate` which takes an `Int`, a value of any type, and returns a list of that type."
    },
    {
        "Statement": "next",
        "Description": "Move to the next case."
    },
    {
        "Statement": "add 10 20",
        "Description": "Call the function 'add' with arguments 10 and 20, resulting in the sum of 10 and 20."
    },
    {
        "Statement": "take' n xs = foldl' (\\acc x -> if length acc < n then acc ++ [x] else acc) [] xs",
        "Description": "The implementation of 'take'' uses 'foldl'' to fold the input list 'xs' using an anonymous function that appends the current element 'x' to the accumulator 'acc' if the length of 'acc' is less than 'n'. The initial accumulator is an empty list '[]'."
    },
    {
        "Statement": "y :: Bool",
        "Description": "Declare a variable 'y' with type Bool."
    },
    {
        "Statement": "con \"sum\" (sum :: [Int] -> Int),",
        "Description": "Include the 'sum' function signature."
    },
    {
        "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
        "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
    },
    {
        "Statement": "length :: Seq a -> Int",
        "Description": "Declare a function length that returns the length of a sequence."
    },
    {
        "Statement": "sum = foldr (+) 0",
        "Description": "Define 'sum' as a fold operation using the '+' operator and starting with an initial accumulator of '0'."
    },
    {
        "Statement": "apply (induction t)",
        "Description": "Begin the proof by induction over tree t."
    },
    {
        "Statement": "\"assumes 'sortedT l'\"",
        "Description": "Assume that `l` is sorted."
    },
    {
        "Statement": "data Tree a = Leaf | Node a (Tree a) (Tree a)",
        "Description": "Define a data type named Tree which is either Leaf or a Node containing an element of type a and two subtrees of the same type."
    },
    {
        "Statement": "filter (\\x -> x>2) [1,2,3,4,5]",
        "Description": "Filter the list [1,2,3,4,5] using the predicate function (\\x -> x>2), resulting in [3,4,5]."
    },
    {
        "Statement": "all' :: (a -> Bool) -> [a] -> Bool",
        "Description": "Define a function all' that takes a predicate p and a list xs, and returns True if all elements of xs satisfy the predicate p, otherwise False."
    },
    {
        "Statement": "lemma contains_drop: \"contains P (drop n xs) ⟶ contains P xs\"",
        "Description": "Define a lemma asserting that if `P` holds for an element in the dropped list, then `P` holds for that element in the original list."
    },
    {
        "Statement": "  return :: a -> m a",
        "Description": "Wrap a value into the monadic context."
    },
    {
        "Statement": "zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]",
        "Description": "Define a function zipWith' that takes a function f and two lists xs and ys, and returns a new list containing the result of applying f to each pair of elements from xs and ys."
    },
    {
        "Statement": "deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]",
        "Description": "Define 'deleteBy' as a function which removes the first occurrence of an element that satisfies a predicate from a list."
    },
    {
        "Statement": "sum [] = 0",
        "Description": "The base case for summing an empty list, which returns 0."
    },
    {
        "Statement": "main = putstrun \"Hello World!\"",
        "Description": "Print 'Hello World!' when 'main' is executed."
    },
    {
        "Statement": "    | otherwise = (ys, x:zs)",
        "Description": "Define the condition for the recursive case of the partition function. If the predicate 'p' is not satisfied by the current element 'x', it is added to the second component of the resulting pair."
    },
    {
        "Statement": "transpose [] = []",
        "Description": "Define the base case of the transpose function where an empty list is given, it returns an empty list."
    },
    {
        "Statement": "case maybe_val of",
        "Description": "Begin a case expression to handle the two possible cases of maybe_val: Nothing or Just v."
    },
    {
        "Statement": "signum :: a -> a",
        "Description": "Define the signum operation 'signum' within the 'Num' typeclass which takes a value of type 'a' and returns a value of type 'a'."
    },
    {
        "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
        "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
    },
    {
        "Statement": "class Arrow a => ArrowChoice (a :: _->_ -> *)\n  where\n    lift :: a b c -> a (Either b d) (Either c d)\n    right :: a b c -> a (Either d b) (Either d c)\n    (+++) :: a b c -> a b' c' -> a (Either b b') (Either c c')\n    (|||) :: a b d -> a b d -> a (Either b c) d",
        "Description": "Define a type class 'ArrowChoice' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowChoice' class specifies methods for working with sum types (e.g., 'Either') and choice operations."
    },
    {
        "Statement": "prop x y z = ((x <> y) <> z) === (x <> (y <> z))",
        "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Endo a' by comparing the results of two equivalent expressions involving '<>'."
    },
    {
        "Statement": "insert :: Ord a => a -> [a] -> [a]",
        "Description": "Define a function named insert which takes an element of type a, where a is an instance of the Ord typeclass, and a sorted list of elements of the same type, and inserts the element into the correct position in the list."
    },
    {
        "Statement": "exitFailure :: IO a",
        "Description": "Define a function 'exitFailure' which performs an IO action that terminates the program with a failure status."
    },
    {
        "Statement": "union' :: Eq a => [a] -> [a] -> [a]",
        "Description": "Define a function union' that takes two lists xs and ys, and returns a new list containing all the elements of xs and ys with duplicates removed."
    },
    {
        "Statement": "main :: IO ()",
        "Description": "Define a function main of type IO ()."
    },
    {
        "Statement": "endsWith :: Eq a => [a] -> [a] -> Bool",
        "Description": "Define a function 'endsWith' that takes two lists of elements of type"
    },
    {
        "Statement": "instance Monad (Either e)",
        "Description": "Create an instance of the Monad typeclass for the Either e data type, which represents computations that can either succeed with a value of type a or fail with a value of type e."
    },
    {
        "Statement": "concat [] = []",
        "Description": "Define the base case of the concat function where an empty list is given, it returns an empty list."
    },
    {
        "Statement": "intersperse :: a -> Seq a -> Seq a",
        "Description": "Declare a function intersperse that intersperses an element between the elements of a sequence."
    },
    {
        "Statement": "instance Monad (Either e)",
        "Description": "Define a Monad instance for the Either type constructor."
    },
    {
        "Statement": "return x = Cons x Nil",
        "Description": "Define the return function for the List monad, which creates a singleton list containing the input value."
    },
    {
        "Statement": "reverse [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "transpose xss = map head xss : transpose (map tail xss)",
        "Description": "Define the recursive case of the transpose function where a non-empty list of lists is given. It transposes the rows and columns of the list."
    },
    {
        "Statement": "bubbleUp x [] = [x]",
        "Description": "If the accumulator is empty, return a singleton list containing x."
    },
    {
        "Statement": "sum (x:xs) = x + sum xs",
        "Description": "Define the recursive case of the sum function where a non-empty list is given. It adds the first element 'x' to the result of recursively summing the rest of the list 'xs'."
    },
    {
        "Statement": "readUntilWithCount ending = aux ending 0",
        "Description": "Define the `readUntilWithCount` function by calling an auxiliary function `aux` with the `ending` string and an initial count of `0`."
    },
    {
        "Statement": "minimum [x] = x",
        "Description": "If the list has only one element, return that element."
    },
    {
        "Statement": "elem _ [] = False",
        "Description": "If the list is empty, return `False`."
    },
    {
        "Statement": "have tv disjunct: \"(Vlv € setT l. lv S tv) A (Vrv € setT r. rv 2 tv)\" using \"2.prems\" sortedT values sets by k",
        "Description": "assert the disjunction of 'tv' with the set 'l' and 'r'."
    },
    {
        "Statement": "import Data.List (intercalate)",
        "Description": "Import the 'intercalate' function from the Data.List module, which inserts a given string between the elements of a list."
    },
    {
        "Statement": "unwords [w] = w",
        "Description": "Define the special case of the unwords function where a single word is given, it returns the word as it is."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "toGraph nodes = buildG (0, length nodes - 1) edges",
        "Description": "Implement 'toGraph' by calling 'buildG' with the appropriate node range and a list of edges derived from the node list."
    },
    {
        "Statement": "bindIOM iom f = do",
        "Description": "Begin the definition of bindIOM by using a do block."
    },
    {
        "Statement": "instance Monoid w => MonadTrans (WriterT w) where\n    lift m = WriterT $ do\n        a <- m\n        return (a, mempty)",
        "Description": "Provide an instance of the 'MonadTrans' type class for the 'WriterT' monad transformer, assuming that 'w' is an instance of the 'Monoid' type class. This instance allows for lifting computations into the 'WriterT' monad transformer."
    },
    {
        "Statement": "con \"product\" (product :: [Int] -> Int),",
        "Description": "Include the 'product' function signature."
    },
    {
        "Statement": "else readUntil ending",
        "Description": "If the input is not the ending string, recursively call readUntil with the ending string."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "sum (x: xs) = x + sum xs",
        "Description": "Sum the first element x with the sum of the remaining elements xs recursively."
    },
    {
        "Statement": "count <- get",
        "Description": "Retrieve the current count value from the state using the `get` function."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "main :: 10 ()",
        "Description": "Define the 'main' function."
    },
    {
        "Statement": "bubbleSort [] = []",
        "Description": "If the input list is empty, return an empty list."
    },
    {
        "Statement": "drop' n xs = foldl' (\\acc x -> if n == 0 then acc ++ [x] else acc) [] xs",
        "Description": "The implementation of 'drop'' uses 'foldl'' to fold the input list 'xs' using an anonymous function that appends the current element 'x' to the accumulator 'acc' if 'n' is equal to 0. The initial accumulator is an empty list '[]'."
    },
    {
        "Statement": "concatMapSig :: [Sig]",
        "Description": "Define 'concatMapSig' as a list of Sig."
    },
    {
        "Statement": "add :: Int -> Int -> Int",
        "Description": "Define a function 'add' which takes two 'Int' arguments and returns an 'Int'."
    },
    {
        "Statement": "bubbleSort xs = bSort xs []",
        "Description": "Otherwise, call the helper function bSort with the input list xs and an empty accumulator."
    },
    {
        "Statement": "take _ [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "loop f b = let (c, d) = f(b, d) in c",
        "Description": "Define the loop function for the ArrowApply instance of (->) that takes a function f and a value b, applies f to (b, d) where d is some undefined value, and returns the first component of the result."
    },
    {
        "Statement": "preOrder (Node x l r) = [x] ++ preOrder l ++ preOrder r",
        "Description": "Otherwise, return the concatenation of a singleton list containing the value at the root, the pre-order traversal of the left subtree, and the pre-order traversal of the right subtree."
    },
    {
        "Statement": "Nothing -> return Nothing",
        "Description": "If maybe_val is Nothing, return Nothing."
    },
    {
        "Statement": "x (D2 1 2)",
        "Description": "Access the 'x' coordinate of a 2D point, yielding '1'."
    },
    {
        "Statement": "instance Num a => Monoid (Sum a) where",
        "Description": "Define a 'Monoid' instance for the 'Sum' data type, constrained by the 'Num' type class constraint on 'a'."
    },
    {
        "Statement": "treeToSeq Leaf = empty",
        "Description": "For an empty tree, return an empty sequence."
    },
    {
        "Statement": "in_range 0 5 3 <-- correct",
        "Description": "Call the 'in_range' function with arguments 0, 5, and 3. This is a correct usage."
    },
    {
        "Statement": "instance (Monoid w, Monad m) => MonadWriter w (StateT s m) where\n    tell w = state $ \\s -> ((), s `mappend` w)\n    listen (StateT m) = StateT $ \\s -> do\n        ((a, s'), w) <- listen (m s)\n        return ((a, w), s')\n    pass (StateT m) = StateT $ \\s -> do\n        ((a, f), s') <- pass (m s)\n        return (a, f s')",
        "Description": "Provide an instance of the 'MonadWriter' type class for the 'StateT' monad transformer, assuming that 'm' is an instance of the 'Monad' type class and 'w' is an instance of the 'Monoid' type class. This instance allows for working with computations that produce a log along with a value within the 'StateT' monad transformer."
    },
    {
        "Statement": "splice xs [] = xs",
        "Description": "If the second list is empty, return the first list xs as the result of splicing."
    },
    {
        "Statement": "capitalize [] = []",
        "Description": "For an empty string, 'capitalize' returns an empty string."
    },
    {
        "Statement": "bindIOM :: IOMaybe a -> (a -> IOMaybe b) -> IOMaybe b",
        "Description": "Define a function bindIOM that takes an IOMaybe a and a function from a to IOMaybe b, and returns an IOMaybe b."
    },
    {
        "Statement": "unzip :: [(a, b)] -> ([a], [b])",
        "Description": "Define a function named `unzip` which takes a list of pairs and returns a pair of lists."
    },
    {
        "Statement": "fun fromList [] = Leaf",
        "Description": "If the list is empty, return an empty tree."
    },
    {
        "Statement": "findIndex x = elemIndex x",
        "Description": "Define 'findIndex' as the 'elemIndex' function, which returns the index of the first occurrence of an element in a list, or 'Nothing' if the element is not found."
    },
    {
        "Statement": "instance Monad []",
        "Description": "Define a Monad instance for lists."
    },
    {
        "Statement": "main = do\n i <- getLine\n if i /= \"quit\" then do\n    putStrLn (\"Input: \"++ i)\n    main\n else\n    return ()",
        "Description": "Define the main function which repeatedly prompts the user for input until 'quit' is entered, then terminates."
    },
    {
        "Statement": "import Data.List (elemIndex)\n\nfirstIndexOf :: Eq a => a -> [a] -> Maybe Int",
        "Description": "Define a function 'firstIndexOf' that takes an element and a list of elements of the same type 'a' that implements the 'Eq' typeclass, and returns the index (zero-based) of the first occurrence of the element in the list, wrapped in a 'Maybe' data type. Import the 'elemIndex' function from the 'Data.List' module."
    },
    {
        "Statement": "newEmptyMVar :: IO (MVar a)",
        "Description": "Create a new empty MVar, which is a synchronized mutable variable that can be used for communication between threads."
    },
    {
        "Statement": "fun insert v (Node l tv r) = (if v ≤ tv then (Node (insert v l) tv r) else (Node l tv (insert v r)))",
        "Description": "Otherwise, insert `v` into the appropriate branch depending on the comparison of `v` and `tv`."
    },
    {
        "Statement": "module Main where",
        "Description": "Define the module 'Main'."
    },
    {
        "Statement": "map :: Monad m => (a -> b) -> m a -> m b\n\nmap f = fmap f",
        "Description": "Define a function map that takes a function (a -> b) and a monadic value m a and returns a monadic value m b, by applying fmap to the function f and the monadic value."
    },
    {
        "Statement": "unwords' :: [String] -> String",
        "Description": "Define a function unwords' that takes a list of words and joins them together using whitespace characters."
    },
    {
        "Statement": "isPalindrome str = str == reverse str",
        "Description": "Check if the input string is equal to its reverse to determine if it's a palindrome."
    },
    {
        "Statement": "put (count + 1)",
        "Description": "Update the state by incrementing the current count by 1 and storing the new value using the `put` function."
    },
    {
        "Statement": "Lemma sorted_tree:",
        "Description": "Define a lemma named sorted_tree."
    },
    {
        "Statement": " of boolean values using the '||' operator (logical OR) and an initial accumulator value of 'False'."
    },
    {
        "Statement": "sortString = sort",
        "Description": "Use the `sort` function to sort the input string in ascending order."
    },
    {
        "Statement": "singleton :: a -> Set a",
        "Description": "Declare a function singleton that creates a set with a single element."
    },
    {
        "Statement": "Just 1 >> Nothing",
        "Description": "Perform the (>>) operation with Just 1 and Nothing, resulting in Nothing."
    },
    {
        "Statement": "greet person = \"Hi\" ++ name person",
        "Description": "Define 'greet' function to concatenate \"Hi\" with the name of the person passed as argument."
    },
    {
        "Statement": "newtype Any a = Any { getAny :: a }",
        "Description": "Define a new data type called 'Any' with a single constructor 'Any' that wraps a value of type 'a'. The 'getAny' function extracts the value of type 'a' from the 'Any' constructor."
    },
    {
        "Statement": "fun mirror :: \"'a Tree → 'a Tree\"",
        "Description": "Define a function named `mirror` which takes a `Tree` and returns a `Tree`."
    },
    {
        "Statement": "app (\\x -> x+1) 1",
        "Description": "Applly the anonymous function (\\x -> x+1) to the value 1 using the 'app' function, resulting in 2."
    },
    {
        "Statement": "quicksort :: Ord a => [a] -> [a]",
        "Description": "Define a function named `quicksort` which takes a list of type `[a]` and returns a sorted list of the same type."
    },
    {
        "Statement": "m >>= f = case m of",
        "Description": "Define a function (>>=) which takes a Maybe value m and a function f, and performs a case analysis on m."
    },
    {
        "Statement": "sum [] = 0",
        "Description": "The base case for summing an empty list, which returns 0."
    },
    {
        "Statement": "instance MonadTrans (ReaderT r) where\n    lift m = ReaderT (const m)",
        "Description": "Provide an instance of the 'MonadTrans' type class for the 'ReaderT' monad transformer. This instance allows for lifting computations into the 'ReaderT' monad transformer."
    },
    {
        "Statement": "name arg1 arg2 ... argn",
        "Description": "Define a function named 'name' with 'n' arguments 'arg1' to 'argn'."
    },
    {
        "Statement": "lift3 f a b c = lift2 f a b <\\*\\*> c",
        "Description": "Define a function lift3 that takes three arguments f, a, b, and c. It applies the lift2 function to f, a, and b, and then applies the <\\*\\*> operator to the result and c."
    },
    {
        "Statement": "failing :: IO ()",
        "Description": "Define a function failing of type IO () that throws an exception of type Error."
    },
    {
        "Statement": "mono TypeObserve (Proxy :: Proxy Float),",
        "Description": "Include the 'Float' type proxy in 'complexSig'."
    },
    {
        "Statement": "empty :: Seq a",
        "Description": "Declare an empty sequence."
    },
    {
        "Statement": "mergeSort xs = merge (mergeSort left) (mergeSort right)",
        "Description": "For a non-empty list, 'mergeSort' divides the list into two halves, recursively sorts each half, and then merges the sorted halves using the 'merge' function."
    },
    {
        "Statement": "mapA :: ArrowChoice a => a a1 a2 -> a [a1] [a2]\nmapA f =\n  arr listCase >>>\n  arr (const []) ||| (f *** mapA f >>> arr (uncurry (:)))",
        "Description": "Define a function 'mapA' that takes an arrow 'f' and applies it to each element of a list. It uses the 'ArrowChoice' operations to implement map in a point-free style."
    },
    {
        "Statement": "instance Semigroup (All a) where",
        "Description": "Define a 'Semigroup' instance for the 'All' data type."
    },
    {
        "Statement": "con \"divide\" (div :: Int -> Int -> Int),",
        "Description": "Include the 'divide' function signature."
    },
    {
        "Statement": "getName = do",
        "Description": "Begin the definition of the `getName` function using the do notation for monadic computations."
    },
    {
        "Statement": "data Maybe a = Nothing | Just a",
        "Description": "Define a data type named Maybe which is either Nothing or Just containing an element of type a."
    },
    {
        "Statement": "theory Tree",
        "Description": "Define a theory named `Tree`."
    },
    {
        "Statement": "concat (xs:xss) = xs ++ concat xss",
        "Description": "Define the recursive case of the concat function where a non-empty list of lists is given. It concatenates the first list with the result of recursively concatenating the rest of the lists."
    },
    {
        "Statement": "instance Monad List where",
        "Description": "Define an instance of the Monad typeclass for the List data type."
    },
    {
        "Statement": "calc (Mul x y) = xy",
        "Description": "Define the 'calc' function pattern matching on the 'Mul' constructor, returning the product of 'x' and 'y'."
    },
    {
        "Statement": "splice [] [] = []",
        "Description": "Define the splice function for two empty lists to return an empty list."
    },
    {
        "Statement": "checkInput [] = False",
        "Description": "If the input string is empty, return False."
    },
    {
        "Statement": "splitEvenOdd xs = partition even xs",
        "Description": "The implementation of 'splitEvenOdd' uses the 'partition' function to split the input list 'xs' into two lists based on the 'even' predicate, which separates the even and odd numbers."
    },
    {
        "Statement": "import Data.List (tails)\n\nsuffixes :: [a] -> [[a]]",
        "Description": "Define a function 'suffixes' that takes a list of elements of any type 'a' and returns a list of all suffixes (remaining segments) of the input list, including the empty list and the input list itself. Import the 'tails' function from the 'Data.List' module."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
    },
    {
        "Statement": "(>>>=) = bindIOM",
        "Description": "Define the (>>>=) operator as bindIOM."
    },
    {
        "Statement": "case True",
        "Description": "If the case is True,"
    },
    {
        "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
        "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'All a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
    },
    {
        "Statement": "checkFirstChar [] = False",
        "Description": "If the input string is empty, return False."
    },
    {
        "Statement": "foldl1' :: (a -> a -> a) -> Seq a -> a",
        "Description": "Declare a function foldl1' that folds a non-empty sequence strictly from the left with a binary function."
    },
    {
        "Statement": "(<**>) :: Monoidal f => f (a -> b) -> f a -> f b",
        "Description": "Declare the '(<**>)' operator signature for the 'Monoidal' type class, which takes a value of type 'f (a -> b)' and a value of type 'f a', and returns a value of type 'f b' by applying the functions in the first argument to the values in the second argument."
    },
    {
        "Statement": "instance MonadFix m => MonadFix (ReaderT r m) where\n    mfix f = ReaderT $ \\r -> mfix (\\a -> runReaderT (f a) r)",
        "Description": "Provide an instance of the 'MonadFix' type class for the 'ReaderT' monad transformer, assuming that 'm' is an instance of the 'MonadFix' type class. This instance allows for creating recursive computations within the 'ReaderT' monad transformer."
    },
    {
        "Statement": "(\\*\\*) :: Applicative f => f a -> f b -> f (a,b)\n\n(\\*\\*) fa fb = pure (,) <\\*> fa <\\*> fb",
        "Description": "Define an operator (\\*\\*) that takes two Applicative functors f a and f b and returns their product f (a,b), using the pure and (<\\*>) functions from the Applicative typeclass."
    },
    {
        "Statement": "import Data.Ord ( comparing )",
        "Description": "Import the 'comparing' function from Data.Ord module."
    },
    {
        "Statement": "Nothing -> Nothing",
        "Description": "If m is Nothing, then return Nothing."
    },
    {
        "Statement": "bindIOM :: IOMaybe a -> (a -> IOMaybe b) -> IOMaybe b",
        "Description": "Define a function bindIOM that takes an IOMaybe a and a function from a to IOMaybe b, and returns an IOMaybe b."
    },
    {
        "Statement": "else return Nothing",
        "Description": "If the input is not valid, return a failed IOMaybe computation by returning Nothing."
    },
    {
        "Statement": "(>>>=) = bindIOM",
        "Description": "Define the (>>>=) operator as bindIOM."
    },
    {
        "Statement": "import Control.Exception",
        "Description": "Import the Control.Exception module."
    },
    {
        "Statement": "con \"subtract\" ((-) :: Int -> Int -> Int),",
        "Description": "Include the 'subtract' function signature."
    },
    {
        "Statement": "map2D :: (a -> b) -> [[a]] -> [[b]]",
        "Description": "Declare 'map2D' as a function taking a function from 'a' to 'b' and a list of lists of 'a's, returning a list of lists of 'b's."
    },
    {
        "Statement": "lemma setT insert: \"setT (insert v t) = setT t U {v}\"",
        "Description": "Define a lemma asserting the set of a tree after inserting `v` is equal to the set of the original tree unioned with `{v}`."
    },
    {
        "Statement": "uniqueSort = nub . sort",
        "Description": "The implementation of 'uniqueSort' uses function composition: first, sort the input list using 'sort', then remove duplicate elements using 'nub'."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "sum (splice xs ys) =?= sum xs + sum ys",
        "Description": "Verify whether the sum of splicing two lists xs and ys is equal to the sum of the individual lists xs and ys."
    },
    {
        "Statement": "deriving (Eq, Ord, ..... )",
        "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'Product' data type."
    },
    {
        "Statement": "instance Monad ((->) r) where\n    return = const\n    m >>= k = \\r -> k (m r) r\n    (>>) = (*>)",
        "Description": "Provide an instance of the 'Monad' type class for the function type constructor '(->) r'. This instance allows for sequencing and combining computations that take a value of type 'r' as input."
    },
    {
        "Statement": "qed",
        "Description": "Close the current proof."
    },
    {
        "Statement": "instance Monad ((->) r)",
        "Description": "Create an instance of the Monad typeclass for the function type constructor (->) r, which represents computations that take a value of type r as input and return a value of type a."
    },
    {
        "Statement": "unit = [()]",
        "Description": "Define the 'unit' value for the 'Monoidal' instance of '[]' as a list containing the unit value '()'."
    },
    {
        "Statement": "apply (simp add: sorted_append)",
        "Description": "Apply the simp tactic with the additional information sorted_append."
    },
    {
        "Statement": "commonElements xs ys = intersect xs ys",
        "Description": "The implementation of 'commonElements' simply applies the 'intersect' function to the two input lists 'xs' and 'ys'."
    },
    {
        "Statement": "drop :: Int -> [a] -> [a]",
        "Description": "Define a function named `drop` which takes an `Int` and a list of any type and returns a list of the same type."
    },
    {
        "Statement": "lines :: String -> [String]",
        "Description": "Define 'lines' as a function which breaks a string up into a list of strings at newline characters."
    },
    {
        "Statement": "reverse' :: [a] -> [a]",
        "Description": "Define a function reverse' that takes a list xs and returns a new list containing the elements of xs in reverse order."
    },
    {
        "Statement": "sum :: Num p => [p] -> p",
        "Description": "sum is a function which takes a list of values of type 'p' belonging to the 'Num' typeclass and returns a single value of type 'p'."
    },
    {
        "Statement": "(Cons x xs) >>= f = append (f x) (xs >>= f)",
        "Description": "If the input to the bind operation is Cons x xs, apply the function f to x, recursively apply the bind operation to xs, and concatenate the results."
    },
    {
        "Statement": "class Applicative m => Monad (m :: _\\->_ )\n\nwhere\n\n    (>>=) :: m a -> (a -> m b) -> m b\n\n    (>>) :: m a -> m b -> m b\n\n    return :: a -> m a",
        "Description": "Define a typeclass Monad that extends the Applicative typeclass. It has three member functions: (>>=) that takes a monadic value m a and a function (a -> m b) and returns a monadic value m b, (>>) that takes two monadic values m a and m b and returns m b, and return that takes a value a and returns a monadic value m a."
    },
    {
        "Statement": "add x = (\\y -> x+y)",
        "Description": "Define the 'add' function where it partially applies 'x' to a lambda function taking 'y' as argument, returning their sum."
    },
    {
        "Statement": "else aux ending ncount",
        "Description": "If the input string is not equal to the ending string, recursively call aux with the ending string and the new count."
    },
    {
        "Statement": "data List a = Nil | Cons a (List a)",
        "Description": "Define a data type named List which is either Nil or a Cons cell containing an element of type a and a List of the same type."
    },
    {
        "Statement": "scanl1 :: (a -> a -> a) -> Seq a -> Seq a",
        "Description": "Declare a function scanl1 that scans a non-empty sequence from the left with a binary function."
    },
    {
        "Statement": "sortBy cmp (x:xs) = sortBy cmp (filter (\\y -> cmp y x == LT) xs) ++ [x] ++ sortBy cmp (filter (\\y -> cmp y x /= LT) xs)",
        "Description": "Define the recursive case of the sortBy function where a non-empty list is given. It sorts the list using the comparison function 'cmp'."
    },
    {
        "Statement": "lift2 f x = (<**>) (fmap f x)",
        "Description": "Define the 'lift2' function by applying 'fmap' to the input function 'f' and the input value 'x' of type 'f a', and then using the '(<**>)' operator to apply the resulting functions to the input value 'x'."
    },
    {
        "Statement": "con \":^:\" ((++) :: [[a]] -> [[a]] -> [[a]]),",
        "Description": "Include the ':^:' operator signature."
    },
    {
        "Statement": "checkInput (x:_) = isUpper x",
        "Description": "If the input String is non-empty, check if the first character is an uppercase letter using the isUpper function, and return the result as a Bool."
    },
    {
        "Statement": "import Data.Either (partitionEithers)\n\nsplitEithers :: [Either a b] -> ([a], [b])",
        "Description": "Define a function 'splitEithers' that takes a list of 'Either' values and returns a tuple containing two lists: one with the 'Left' values and one with the 'Right' values. Import the 'partitionEithers' function from the 'Data.Either' module."
    },
    {
        "Statement": "(+) :: a -> a -> a",
        "Description": "Define the addition operation '+' within the 'Num' typeclass which takes two values of type 'a' and returns a value of type 'a'."
    },
    {
        "Statement": "con \"isEmpty\" (null :: [a] -> Bool),",
        "Description": "Include the 'isEmpty' function signature."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Read a line of input from the user and bind it to input."
    },
    {
        "Statement": "con \"tailElements\" (tail :: [a] -> [a]),",
        "Description": "Include the 'tailElements' function signature."
    },
    {
        "Statement": "    | otherwise = lookup y xys",
        "Description": "Define the condition for the recursive case of the lookup function. If the key 'y' is not found, it recursively searches in the rest of the list."
    },
    {
        "Statement": "exitFailure = System.Exit.exitFailure",
        "Description": "Implement the 'exitFailure' function using 'System.Exit.exitFailure'."
    },
    {
        "Statement": "capitalize (x:xs) = toUpper x : xs",
        "Description": "For a non-empty string, 'capitalize' converts the first character to uppercase and concatenates it with the remaining characters."
    },
    {
        "Statement": "cross = (,)",
        "Description": "Implement the 'cross' function using the tuple constructor '(,)'."
    },
    {
        "Statement": "then returnIOM input",
        "Description": "If the input is valid, return a successful IOMaybe computation with the input String."
    },
    {
        "Statement": "| otherwise = func (x-y) (y*2) (z+1)",
        "Description": "Otherwise, recursively call `func` with `(x-y)`, `(y*2)`, and `(z+1)`."
    },
    {
        "Statement": "postOrder (Node x l r) = postOrder l ++ postOrder r ++ [x]",
        "Description": "Otherwise, return the concatenation of the post-order traversal of the left subtree, the post-order traversal of the right subtree, and a singleton list containing the value at the root."
    },
    {
        "Statement": "import Data.List (permutations)\n\npermutations' :: [a] -> [[a]]",
        "Description": "Define a function 'permutations'' that takes a list of elements of any type 'a' and returns a list of all permutations of the input list. Import the 'permutations' function from the 'Data.List' module."
    },
    {
        "Statement": "age :: Person -> Int",
        "Description": "Define a function 'age' which takes a 'Person' and returns their age."
    },
    {
        "Statement": "capitalize :: String -> String",
        "Description": "Define a function 'capitalize' that takes a string and returns a new string with the first character capitalized."
    },
    {
        "Statement": "type IOMaybe a = IO (Maybe a)",
        "Description": "Define a new type synonym IOMaybe a that represents a computation that can perform side effects and either succeed with a value of type a or fail without a value."
    },
    {
        "Statement": "progname arg1 arg2 arg3 arg4",
        "Description": "Define a program with four arguments."
    },
    {
        "Statement": "lemma tree_union:",
        "Description": "Define a lemma named tree_union."
    },
    {
        "Statement": "f xs = map (\\x -> x+1) $ filter (\\x -> x>1) xs",
        "Description": "Define the function 'f' where the '$' operator is used to replace the parentheses, indicating that the result of 'filter' is passed as an argument to 'map'."
    },
    {
        "Statement": "getLine",
        "Description": "Read a line of input from the user."
    },
    {
        "Statement": "maybeadd :: Num b => Maybe b -> Maybe b -> Maybe b",
        "Description": "Redefine `maybeadd` to accept two Maybe-wrapped values and add them."
    },
    {
        "Statement": "elemIndex _ [] = Nothing",
        "Description": "Define the case of the elemIndex function where an empty list is given, it returns Nothing."
    },
    {
        "Statement": "main :: IO ()",
        "Description": "Define the 'main' function."
    },
    {
        "Statement": "insert x (y:ys) | otherwise = y : insert x ys",
        "Description": "Otherwise, prepend the head of the list to the result of recursively calling insert with x and the tail of the list."
    },
    {
        "Statement": "(<>) = coerce ((&&) :: a -> a -> a)",
        "Description": "Define the '<>' operator for the 'Semigroup' instance of 'All a' by converting the '(&&)' function for type 'a' to the appropriate type using 'coerce'."
    },
    {
        "Statement": "null :: Seq a -> Bool",
        "Description": "Declare a function null that checks if a sequence is empty."
    },
    {
        "Statement": "readUntilWithCount ending = aux ending 0",
        "Description": "Define the implementation of readUntilWithCount by calling the auxiliary function aux with the ending string and an initial count of 0."
    },
    {
        "Statement": "instance Monad Maybe where\n    return = Just\n    Nothing >>= _ = Nothing\n    Just x >>= f  = f x\n    (>>) = (*>)",
        "Description": "Provide an instance of the 'Monad' type class for the 'Maybe' data type. This instance allows for sequencing and combining 'Maybe' computations."
    },
    {
        "Statement": "notElem :: Eq a => a -> Seq a -> Bool",
        "Description": "Declare a function notElem that checks if an element is not in a sequence."
    },
    {
        "Statement": "(<**>) mf mx = fmap (\\(f,x) -> f x) (mf ** mx)",
        "Description": "Define the '(<**>)' operator for the 'Monoidal' type class by applying the functions in 'mf' to the values in 'mx' using the '(**)' operator and 'fmap'."
    },
    {
        "Statement": "abs :: a -> a",
        "Description": "Define the absolute value operation 'abs' within the 'Num' typeclass which takes a value of type 'a' and returns a value of type 'a'."
    },
    {
        "Statement": "import qualified Lib",
        "Description": "Import the 'Lib' module qualified."
    },
    {
        "Statement": "| otherwise = func (x-y) (y*2) (z+1)",
        "Description": "Otherwise, recursively call `func` with `(x-y)`, `(y*2)`, and `(z+1)`."
    },
    {
        "Statement": "hw = putStrLn \"Hello World\"",
        "Description": "Define a function 'hw' that prints 'Hello World' to the console when called."
    },
    {
        "Statement": "filterString = filter isAlpha",
        "Description": "Use the `filter` function with `isAlpha` to remove non-alphabetic characters from the input string."
    },
    {
        "Statement": "where types = (x :: Maybe Int, y :: Maybe Int)",
        "Description": "Specify the types of 'x' and 'y' as 'Maybe' integers for the 'prop' function."
    },
    {
        "Statement": "bindIOM iom f = do",
        "Description": "Begin the implementation of the bindIOM function using the do notation."
    },
    {
        "Statement": "instance Applicative IO where\n\n    pure = return\n\n    a <\\*> b = do\n\n        f <- a\n\n        x <- b\n\n        return (f x)",
        "Description": "Define an instance of the Applicative typeclass for the IO monad. The pure function is implemented using return, and the (<\\*>) operator is implemented using a do block that first gets a function f from a, then a value x from b, and finally applies f to x and returns the result."
    },
    {
        "Statement": "instance Monadfix m => Arrowloop (Kleisli m)",
        "Description": "Create an instance of the Arrowloop typeclass for the Kleisli m newtype, given that m is an instance of the Monadfix class."
    },
    {
        "Statement": "where types = (x :: Bool, y :: Bool)",
        "Description": "Specify the types of 'x' and 'y' as boolean values for the 'prop' function."
    },
    {
        "Statement": "by (metis inorder.simps (2) sorted_append)",
        "Description": "Use the given sorted lemma to solve the subgoal."
    },
    {
        "Statement": "p n= n≥ 0",
        "Description": "Define `p` as a function that takes `n` and returns `True` if `n` is greater than or equal to 0."
    },
    {
        "Statement": "begin",
        "Description": "Begin the theory."
    },
    {
        "Statement": "(- Simple laws about addition -)",
        "Description": "Start of the comment 'Simple laws about addition'."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
    },
    {
        "Statement": "con \"slice\" (takeWhile . dropWhile . not :: (a -> Bool) -> [a] -> [a]),",
        "Description": "Include the 'slice' function signature."
    },
    {
        "Statement": "deriving (Eq, Ord)",
        "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'All' data type."
    },
    {
        "Statement": "height Leaf = 0",
        "Description": "If the input tree is Leaf, return 0."
    },
    {
        "Statement": "z :: Float",
        "Description": "Declare a variable 'z' with type Float."
    },
    {
        "Statement": "trimString = f . f",
        "Description": "Define trimString using the 'f.f' composition to remove leading and trailing whitespace."
    },
    {
        "Statement": "return v = Just v",
        "Description": "Define the return function for the Maybe monad, which takes a value v and wraps it in a Just constructor."
    },
    {
        "Statement": "checkInput [] = False",
        "Description": "If the input string is empty, return False."
    },
    {
        "Statement": "con \"insertAt\" (insert :: Ord a => a -> [a] -> [a]),",
        "Description": "Include the 'insertAt' function signature."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
    },
    {
        "Statement": "sum []",
        "Description": "Define the sum of an empty list as 0."
    },
    {
        "Statement": "func x = if x == 0 then ( else f (x-1))",
        "Description": "Define `func` to return `f (x-1)` if `x` is equal to 0."
    },
    {
        "Statement": "    | eq x y = xs",
        "Description": "Define the condition for the recursive case of the deleteBy function. If the predicate 'eq' is satisfied by the current element 'x' and 'y', it returns the rest of the list."
    },
    {
        "Statement": "reverse (Cons x xs) = append (reverse xs) (Cons x Nil)",
        "Description": "Otherwise, recursively call reverse with the tail of the list and prepend the head of the list to the result."
    },
    {
        "Statement": "if (1+1) 'mod' 2 == 0 then (1+1) else (2+1)",
        "Description": "Evaluate the expression using if-then-else, if (1+1) is even, return (1+1), otherwise return (2+1)."
    },
    {
        "Statement": "con \"concatMap\"\n-> [A]),",
        "Description": "Declare the signature for 'concatMap' function."
    },
    {
        "Statement": "| n == 0      =1",
        "Description": "If `n` is equal to 0, return 1."
    },
    {
        "Statement": "fromList :: Ord a => [a] -> Seq a",
        "Description": "Declare a function fromList that takes a list and returns a sequence."
    },
    {
        "Statement": "int z = func3 (arg);",
        "Description": "Define a variable 'z' of type integer which is assigned the result of calling function 'func3' with argument 'arg'."
    },
    {
        "Statement": "newtype StateT s (m :: * -> *) a",
        "Description": "Declare a new type constructor `StateT` that represents a state transformer monad, parameterized by the state type `s`, a base monad `m`, and the result type `a`."
    },
    {
        "Statement": "insert' :: Ord a => a -> [a] -> [a]",
        "Description": "Define a function insert' that takes an element x and a sorted list xs, and returns a new sorted list with x inserted into xs, maintaining the ordering."
    },
    {
        "Statement": "n == 0 =1",
        "Description": "If `n` is equal to 0, return 1."
    },
    {
        "Statement": "calc :: Calculation -> Int",
        "Description": "Define a function 'calc' which takes a 'Calculation' and returns an 'Int'."
    },
    {
        "Statement": "sortBy :: (a -> a -> Ordering) -> [a] -> [a]",
        "Description": "Define 'sortBy' as a function which sorts a list by the given comparison function."
    },
    {
        "Statement": "(concatMap :: (A -> [B]) -> [A] -> [BJ),",
        "Description": "Define 'concatMap' as a function which takes two arguments of type 'A' and returns a list of 'B'."
    },
    {
        "Statement": "delete :: Eq a => a -> [a] -> [a]",
        "Description": "Define 'delete' as a function which removes the first occurrence of the given element from the list."
    },
    {
        "Statement": "\"sortedT t At = (Node l v r) → sortedT 1 A sortedT r\"",
        "Description": "If the tree t is sorted, then for every Node l v r, l and r are sorted."
    },
    {
        "Statement": "drop n (_:xs) = drop (n-1) xs",
        "Description": "Otherwise, drop `n` elements from the list."
    },
    {
        "Statement": "data Node a = Node a [Node a]",
        "Description": "Define a data type 'Node a' to represent a node in a graph, where each node contains a value of type 'a' and a list of child nodes."
    },
    {
        "Statement": "evens (x:xs)\n | mod x 2 == 0 = x : evens xs,\n | otherwise = evens xs",
        "Description": "If the head of the list 'x' is even, add to the result list, and the function is called recursively on the rest of the list 'xs'. If the head of the list 'x' is odd, it is not added to the result list, and the function is called recursively on the rest of the list 'xs'."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the auto tactic to automatically solve the generated subgoals."
    },
    {
        "Statement": "map :: (a -> b) -> [a] -> [b]",
        "Description": "Define a function 'map' that takes a function 'f' and a list 'xs' as arguments, and applies 'f' to each element of 'xs', returning a list of the results."
    },
    {
        "Statement": "import Data.List (foldl')\n\nconcat' :: [[a]] -> [a]",
        "Description": "Define a function 'concat'' that takes a list of lists of elements of any type 'a' and returns a single list containing all the elements concatenated. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "instance Num a => Monoid (Product a) where",
        "Description": "Define a 'Monoid' instance for the 'Product' data type, constrained by the 'Num' type class constraint on 'a'."
    },
    {
        "Statement": "(>>>=) = bindIOM",
        "Description": "Define the fish operator (>>>=) as a synonym for the bindIOM function, which is a common convention in Haskell."
    },
    {
        "Statement": "by auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "exitSuccess = System.Exit.exitSuccess",
        "Description": "Implement the 'exitSuccess' function using 'System.Exit.exitSuccess'."
    },
    {
        "Statement": "[1,2,3,4,5]",
        "Description": "Define a list containing integers 1 through 5 using the cons operator (:)."
    },
    {
        "Statement": "return xs'",
        "Description": "Return the shuffled string."
    },
    {
        "Statement": "fun mirror (Node l v r) = Node (mirror r) v (mirror l)",
        "Description": "Otherwise, create a node with mirrored left and right branches."
    },
    {
        "Statement": "sum (splice xs ys) =?= sum xs + sum ys",
        "Description": "Verify whether the sum of splicing two lists xs and ys is equal to the sum of the individual lists xs and ys."
    },
    {
        "Statement": "if checkInput input",
        "Description": "Check if the input is valid using the checkInput function."
    },
    {
        "Statement": "return x = Just x",
        "Description": "Define the return function for the Maybe monad, which wraps a value in Just."
    },
    {
        "Statement": "module DataStructures",
        "Description": "Define a module named DataStructures."
    },
    {
        "Statement": "class Ord a where {",
        "Description": "Define a class 'Ord' with type variable 'a' where,"
    },
    {
        "Statement": "maximum :: Ord a => Seq a -> a",
        "Description": "Declare a function maximum that returns the maximum element of a sequence."
    },
    {
        "Statement": "rights :: [Either a b] -> [b]",
        "Description": "Define a function 'rights' that takes a list of 'Either' values and returns a list containing only the 'Right' values."
    },
    {
        "Statement": "preOrder Leaf = []",
        "Description": "If the input tree is Leaf, return an empty list."
    },
    {
        "Statement": "contains P [] = False",
        "Description": "Define `contains` as a function that returns `False` when the list is empty."
    },
    {
        "Statement": "newtype StateT s (m :: * -> *) a",
        "Description": "Declare a new type constructor `StateT` that represents a state transformer monad, parameterized by the state type `s`, a base monad `m`, and the result type `a`."
    },
    {
        "Statement": "instance Monoid [a] where\n  mempty = []\n  mconcat xss = [x | xs <- xss, x <- xs]",
        "Description": "Provide an instance of Monoid for lists, where mempty is the empty list, and mconcat concatenates a list of lists by flattening them into a single list."
    },
    {
        "Statement": "in_range min max x = x >= min && x <= max",
        "Description": "Define the 'in_range' function to check if 'x' is within the range [min, max]."
    },
    {
        "Statement": "sum (x: xs) = x + sum xs",
        "Description": "Sum the first element x with the sum of the remaining elements xs recursively."
    },
    {
        "Statement": "reverse :: List a -> List a",
        "Description": "Define a function named reverse which takes a List of elements of type a and returns a List of the same type with the elements in reverse order."
    },
    {
        "Statement": "descSort = reverse . sort",
        "Description": "Define 'descSort' as the composition of 'reverse' and 'sort' functions."
    },
    {
        "Statement": "data Point = D2 {x :: Int, y :: Int} | D3 {x :: Int, y :: Int, z :: Int}",
        "Description": "Define a datatype 'Point' with two constructors: 'D2' taking 'x' and 'y' coordinates, and 'D3' taking 'x', 'y', and 'z' coordinates."
    },
    {
        "Statement": "insertionSort [] = []",
        "Description": "If the input list is empty, return an empty list."
    },
    {
        "Statement": "assumes",
        "Description": "Specify assumptions for the lemma."
    },
    {
        "Statement": "mempty = Product 1",
        "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Product a' as a 'Product' value wrapping the number '1'."
    },
    {
        "Statement": "con \"fibonacci\" (fib :: Int -> Int),",
        "Description": "Include the 'fibonacci' function signature."
    },
    {
        "Statement": "instance Monad a => Monad ((,) a)",
        "Description": "Create an instance of the Monad typeclass for the tuple type constructor (,) a, given that a is an instance of the Monad typeclass."
    },
    {
        "Statement": "func :: Int -> Int -> Int -> Int",
        "Description": "Define a function named `func` which takes three `Int` parameters and returns an `Int`."
    },
    {
        "Statement": "readUntilWithState ending = execStateT (aux ending) 0",
        "Description": "Define the `readUntilWithState` function by executing the `aux` computation within the `StateT` monad transformer, using `execStateT` to discard the result value and return the final state (the count)."
    },
    {
        "Statement": "find _ [] = Nothing",
        "Description": "Define the case of the find function where an empty list is given, it returns Nothing."
    },
    {
        "Statement": "data Tree a = Leaf | Node a (Tree a) (Tree a)",
        "Description": "Define a data type named Tree which is either Leaf or a Node containing an element of type a and two subtrees of the same type."
    },
    {
        "Statement": "data Maybe a = Nothing | Just a",
        "Description": "Define a data type Maybe a that represents an optional value, either Nothing or Just a."
    },
    {
        "Statement": "lift2 f x = (<**>) (fmap f x)",
        "Description": "Define the 'lift2' function by applying 'fmap' to the input function 'f' and the input value 'x' of type 'f a', and then using the '(<**>)' operator to apply the resulting functions to the input value 'x'."
    },
    {
        "Statement": "addsig - [\ncon\n((+) :: Int -> Int -> Int),",
        "Description": "Declare the signature for addition '(+) :: Int -> Int -> Int'."
    },
    {
        "Statement": "either :: (a ->c) -> (b -> c) -> Either a b -> c",
        "Description": "Define the 'either' function which takes two functions and an 'Either' value, applies the first function to the 'Left' value or the second function to the 'Right' value, and returns the result."
    },
    {
        "Statement": "length (x:xs) =?= foldr (const (+1)) 0 (x:xs)",
        "Description": "State that the length of a non-empty list (x:xs) is equal to foldr (const (+1)) 0 (x:xs)."
    },
    {
        "Statement": "import Data.List (foldl')\n\nfilter' :: (a -> Bool) -> [a] -> [a]",
        "Description": "Define a function 'filter'' that takes a predicate function 'p :: a -> Bool' and a list of elements of type 'a', and returns a list containing only the elements that satisfy the predicate. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "height (Node _ l r) = 1 + max (height l) (height r)",
        "Description": "Otherwise, return 1 plus the maximum of the heights of the left and right subtrees."
    },
    {
        "Statement": "[1,2,3,4,5] :: [Integer]",
        "Description": "Define a list containing integers 1 through 5."
    },
    {
        "Statement": "in_range min max x = x >= min && x <= max",
        "Description": "Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x'. It returns true if 'x' is within the range [min, max] (inclusive), otherwise false."
    },
    {
        "Statement": "bubbleSort :: Ord a => [a] -> [a]",
        "Description": "Define a function named bubbleSort which takes a list of elements of type a, where a is an instance of the Ord typeclass, and returns a sorted list of the same elements."
    },
    {
        "Statement": "import Data.Either",
        "Description": "Imports the 'Data.Either' module."
    },
    {
        "Statement": "is_zero 0 = True | is_zero _ = False",
        "Description": "Define a function 'is_zero' that pattern matches on its argument. If the argument is 0, return True; otherwise, return False."
    },
    {
        "Statement": "app :: (a -> b) -> a->b",
        "Description": "Define a higher-order function 'app' that takes a function 'f' and a value 'x' as arguments, and applies 'f' to 'x'."
    },
    {
        "Statement": "]",
        "Description": "End of the list."
    },
    {
        "Statement": "sum (splice xs ys) =?= sum xs + sum ys",
        "Description": "Verify whether the sum of splicing two lists xs and ys is equal to the sum of the individual lists xs and ys."
    },
    {
        "Statement": "apply (induction t)",
        "Description": "Begin the proof by induction over tree t."
    },
    {
        "Statement": "(Just v) -> f v",
        "Description": "If maybe_val is Just v, apply the function f to v and return the result."
    },
    {
        "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
        "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Last a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
    },
    {
        "Statement": "                  Nothing -> []",
        "Description": "Define the 'unfoldr' function. If the result of 'f' is Nothing, it terminates the list."
    },
    {
        "Statement": "getName :: IOMaybe String",
        "Description": "Define a function getName that represents an IOMaybe computation that can get a valid name from the user."
    },
    {
        "Statement": "length = foldr (\\_ acc -> acc + 1) 0",
        "Description": "Define 'length' as a fold operation that counts the length of the list."
    },
    {
        "Statement": "lines s = let (l, s') = break (== '\\n') s",
        "Description": "Define the recursive case of the lines function where a non-empty string is given. It breaks the string at the first newline character and returns the line as the first element of the resulting list."
    },
    {
        "Statement": "count <- get",
        "Description": "Retrieve the current count value from the state using the `get` function."
    },
    {
        "Statement": "zip _ [] = []",
        "Description": "If the second list is empty, return an empty list."
    },
    {
        "Statement": "finally :: IO a -> IO b -> IO a",
        "Description": "Create an IO action that runs the first IO action, then runs the second IO action, and finally returns the result of the first IO action, regardless of whether an exception was thrown or not."
    },
    {
        "Statement": "transpose' :: [[a]] -> [[a]]",
        "Description": "Define a function transpose' that takes a list of lists xss, and returns a new list of lists where the rows and columns of xss are swapped."
    },
    {
        "Statement": "trim :: String -> String",
        "Description": "Define a function 'trim' that takes a string and returns the string with leading and trailing whitespace removed."
    },
    {
        "Statement": "flattenBinTree (Node x l r) = x : (flattenBinTree l ++ flattenBinTree r)",
        "Description": "Define a function 'flattenBinTree' that takes a binary tree of type 'Tree a' and returns a list of all the values in the tree, represented in a flattened form."
    },
    {
        "Statement": "or' = foldl' (||) False",
        "Description": "The implementation of 'or'' uses 'foldl'' to fold the input list"
    },
    {
        "Statement": "product [] = 1",
        "Description": "Define the product of an empty list as 1."
    },
    {
        "Statement": "readUntilWithState ending = execStateT (aux ending) 0",
        "Description": "Define the implementation of readUntilWithState by calling execStateT with the auxiliary function aux (using the ending string as an argument) and an initial state of 0."
    },
    {
        "Statement": "maximum :: Ord a => [a] -> a",
        "Description": "Define a function named `maximum` which takes a list of type `[a]` and returns an element of type `a`."
    },
    {
        "Statement": "import Data.List (sort)\n\nsortList :: [Int] -> [Int]",
        "Description": "Define a function 'sortList' that takes a list of integers and returns a sorted list of integers. Import the 'sort' function from the 'Data.List' module."
    },
    {
        "Statement": "have \"Viv € setT (insert v r). iv ≥ tv\" using setT insert tv disjunct False by (metis Un iff le cases single",
        "Description": "assert that all the elements in the setT (insert v r) are greater than or equal to 'tv'."
    },
    {
        "Statement": "data Maybe a = Nothing | Just a",
        "Description": "Define a data type named Maybe which is either Nothing or Just containing an element of type a."
    },
    {
        "Statement": "height Leaf = 0",
        "Description": "If the input tree is Leaf, return 0."
    },
    {
        "Statement": "joinWith :: String -> [String] -> String",
        "Description": "Define a function 'joinWith' that takes a separator string and a list of strings, and returns a single string with the elements of the list joined by the separator."
    },
    {
        "Statement": "zip3' :: [a] -> [b] -> [c] -> [(a, b, c)]",
        "Description": "Define a function zip3' that takes three lists xs, ys, and zs, and returns a list of triples, where each triple contains one element from each list."
    },
    {
        "Statement": "put :: s -> m ()",
        "Description": "Declare a function `put` that takes a new state value and updates the current state within the base monad `m`."
    },
    {
        "Statement": "con \"lowercase\" (map toLower :: String -> String),",
        "Description": "Include the 'lowercase' function signature."
    },
    {
        "Statement": "rdeepseq :: NFData a => Strategy a",
        "Description": "Create a Strategy that evaluates the given value to normal form, fully evaluating all sub-expressions."
    },
    {
        "Statement": "f :: a -> b -> c -> d",
        "Description": "Define a function 'f' that takes three arguments of types 'a', 'b', and 'c', and returns a value of type 'd'."
    },
    {
        "Statement": "ghci> throw ErrorA",
        "Description": "Throw an exception of type ErrorA in GHCi."
    },
    {
        "Statement": "case (Cons x xs)",
        "Description": "If the case is a non-empty list."
    },
    {
        "Statement": "topologicalSort :: [Node a] -> [Node a]",
        "Description": "Define a function 'topologicalSort' that takes a list of nodes '[Node a]' and returns a topologically sorted list of nodes."
    },
    {
        "Statement": "takeWhile _ [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "import Data.List (sort)",
        "Description": "Import the 'sort' function from the Data.List module."
    },
    {
        "Statement": "deriving (Eq, Ord)",
        "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'First' data type."
    },
    {
        "Statement": "bubbleSort :: Ord a => [a] -> [a]",
        "Description": "Define a function named bubbleSort which takes a list of elements of type a, where a is an instance of the Ord typeclass, and returns a sorted list of the same elements."
    },
    {
        "Statement": "put (count + 1)",
        "Description": "Update the state by incrementing the current count by 1."
    },
    {
        "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
        "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
    },
    {
        "Statement": "lookup y ((x,v):xys)",
        "Description": "Define the recursive case of the lookup function where a non-empty list of key-value pairs is given. It searches for the key 'y' in the list."
    },
    {
        "Statement": "sum :: [Int] -> Int",
        "Description": "Define a function named `sum` which takes a list of `Int` and returns an `Int`."
    },
    {
        "Statement": "zip :: [a] -> [b] -> [(a, b)]",
        "Description": "Define a function named `zip` which takes two lists and returns a list of pairs."
    },
    {
        "Statement": "have \"insert v (Node l tv r) = Node l tv (insert v r)\" by (simp add: False)",
        "Description": "then prove the equation 'insert v (Node l tv r) = Node l tv (insert v r)'."
    },
    {
        "Statement": "f X = X : X",
        "Description": "Define a function f which takes an argument X and prepends it twice to itself, which results in a type error due to infinite recursion."
    },
    {
        "Statement": "case (1 v)",
        "Description": "If the case is (1 v),"
    },
    {
        "Statement": "type Path = [B.ByteString]",
        "Description": "Define a type alias 'Path' as a list of 'ByteString' values."
    },
    {
        "Statement": "int x = func1 (arg);",
        "Description": "Define a variable 'x' of type integer which is assigned the result of calling function 'func1' with argument 'arg'."
    },
    {
        "Statement": "Nothing >>= (\\x -> Just x)",
        "Description": "Bind Nothing to the function (\\x -> Just x), resulting in Nothing."
    },
    {
        "Statement": "  (>>=) :: m a -> (a -> m b) -> m b",
        "Description": "Define the bind operator (>>=) which sequences two monadic actions."
    },
    {
        "Statement": "maybeadd Nothing 1",
        "Description": "Applly `maybeadd` function with `Nothing` and `1`, resulting in Nothing."
    },
    {
        "Statement": "getName = do",
        "Description": "Begin the definition of getName by using a do block."
    },
    {
        "Statement": "guard (checkInput input)",
        "Description": "Use the `guard` function to conditionally proceed with the computation based on the result of `checkInput input`, which presumably checks if the input satisfies some condition."
    },
    {
        "Statement": "hn = n",
        "Description": "Assign `hn` the value of `n`."
    },
    {
        "Statement": "sum (x:xs) = x + sum xs",
        "Description": "Define the sum of a list as the first element plus the sum of the rest of the list."
    },
    {
        "Statement": "(<>) _ b = b",
        "Description": "Define the '<>' operator for the 'Semigroup' instance of 'First a' to handle the case where the first value is 'Nothing'."
    },
    {
        "Statement": "foldl' _ z [] = z",
        "Description": "Define the base case for foldl', which returns the initial value z when applied to an empty list."
    },
    {
        "Statement": "instance (Monoid w, Monad m) => MonadWriter w (ExceptT e m) where\n    tell _ = return ()\n    listen (ExceptT m) = ExceptT $ do\n        (result, w) <- listen m\n        return $ case result of\n            Left e -> Left e\n            Right r -> Right (r, w)\n    pass (ExceptT m) = ExceptT $ do\n        result <- m\n        case result of\n            Left (e, f) -> return $ Left e\n            Right (a, f) -> return $ Right a",
        "Description": "Provide an instance of the 'MonadWriter' type class for the 'ExceptT' monad transformer, assuming that 'm' is an instance of the 'Monad' type class and 'w' is an instance of the 'Monoid' type class. This instance allows for working with computations that produce a log along with a value within the 'ExceptT' monad transformer."
    },
    {
        "Statement": "startsWith prefix = isPrefixOf prefix",
        "Description": "Define 'startsWith' as the 'isPrefixOf' function, which checks if a list is a prefix of another list."
    },
    {
        "Statement": "scanl' :: (a -> b -> a) -> a -> [b] -> [a]",
        "Description": "Define a function scanl' that takes a function f, an initial value z, and a list xs, and returns a list of successive reduced values from the left, starting with the initial value z."
    },
    {
        "Statement": "instance Monad [] where\n    return x = [x]\n    xs >>= f = concat (map f xs)\n    (>>) = (*>)",
        "Description": "Provide an instance of the 'Monad' type class for the list data type '[]'. This instance allows for sequencing and combining list computations."
    },
    {
        "Statement": "background [ prelude ]",
        "Description": "Include the Prelude module in the background."
    },
    {
        "Statement": "class Semigroup a where\n  (<>) :: a -> a -> a",
        "Description": "Define a class Semigroup that represents types that have an associative binary operation (<>)."
    },
    {
        "Statement": "con \"factorial\" (factorial :: Int -> Int),",
        "Description": "Include the 'factorial' function signature."
    },
    {
        "Statement": "class Arrow a => ArrowApply (a :: _->_ -> *)\n  where\n    app :: a (a b c, b) c",
        "Description": "Define a type class 'ArrowApply' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowApply' class specifies a single method 'app' for applying an arrow to its input."
    },
    {
        "Statement": "(<>) = coerce ((<>) :: a -> a -> a)",
        "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Dual a' by converting the '(<>)' function for type 'a' to the appropriate type using 'coerce'."
    },
    {
        "Statement": "intersect' :: Eq a => [a] -> [a] -> [a]",
        "Description": "Define a function intersect' that takes two lists xs and ys, and returns a new list containing only the elements that are common to both xs and ys."
    },
    {
        "Statement": "data Maybe a = Nothing | just a",
        "Description": "Define a data type 'Maybe' which represents an optional value, where 'Nothing' indicates absence of a value and 'Just' wraps a value of type 'a'."
    },
    {
        "Statement": "    | otherwise = x : insert y xs",
        "Description": "Define the condition for the recursive case of the insert function. If the element 'y' is greater than the current element 'x', it keeps 'x' and recursively inserts 'y' into the rest of the list."
    },
    {
        "Statement": "maybeadd (Just 1) 1",
        "Description": "Applly `maybeadd` function with `Just 1` and `1`, resulting in Just 2."
    },
    {
        "Statement": "foldr (\\acc elem -> <term>) <start_acc> <list>",
        "Description": "Define a fold operation where the function takes an accumulator and an element as arguments, starting with an initial accumulator value, and folding from the right over the list."
    },
    {
        "Statement": "countDigits = length . filter isDigit",
        "Description": "The implementation of 'countDigits' uses function composition: first, filter the input string to retain only the digits using 'isDigit', then find the length of the resulting list."
    },
    {
        "Statement": "data Temperature = C Float | F Float",
        "Description": "Define a datatype 'Temperature' with two constructors 'C' and 'F' representing temperatures in Celsius and Fahrenheit respectively."
    },
    {
        "Statement": "getName :: IO (Maybe String)",
        "Description": "Define a function getName that returns an IO action that may produce a String, wrapped in a Maybe type."
    },
    {
        "Statement": "group' :: Eq a => [a] -> [[a]]",
        "Description": "Define a function group' that takes a list xs and returns a list of lists, where each inner list contains consecutive equal elements of xs."
    },
    {
        "Statement": "prop x y = (( x <> y) <> mempty) === (x <> (y <> mempty))",
        "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Product a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
    },
    {
        "Statement": "con\n\"revAcc\"",
        "Description": "Declare the signature for 'revAcc' function."
    },
    {
        "Statement": "isNumeric = all isDigit",
        "Description": "Define 'isNumeric' as the composition of the 'all' function (which checks if a predicate holds for all elements of a list) and the 'isDigit' function (which checks if a character is a digit)."
    },
    {
        "Statement": "liftIOm :: IO a -> IOMaybe a",
        "Description": "Define a function liftIOm that takes an IO a and returns an IOMaybe a."
    },
    {
        "Statement": "fromJust :: Maybe a -> a",
        "Description": "Define a function 'fromJust' which extracts the value from a 'Just' constructor. Caution: This function throws an error if given a 'Nothing' value, so it should be used with care."
    },
    {
        "Statement": "if 2 'mod' 2 == 0 then 2 else (2+1)",
        "Description": "Evaluate the expression using if-then-else, if 2 is even, return 2, otherwise return (2+1)."
    },
    {
        "Statement": "lemma setT insert: \"setT (insert v t) = setT t ∪ {v}\"",
        "Description": "Define a lemma asserting the set of a tree after inserting v is equal to the set of the original tree unioned with {v}."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "mempty = NonEmpty (undefined, [])",
        "Description": "Define the 'mempty' value for the 'Monoid' instance of 'NonEmpty a' as a 'NonEmpty' value wrapping an empty tuple and an empty list."
    },
    {
        "Statement": "fac n | n <= 1  =1 | otherwise = n * fac (n-1)",
        "Description": "Define a function 'fac' that calculates the factorial of 'n'. If 'n' is less than or equal to 1, return 1; otherwise, return 'n' multiplied by the factorial of 'n-1'."
    },
    {
        "Statement": "asc n m | m<n = [] | m==n = [m] | m>n = n : asc (n+1) m",
        "Description": "Define the implementation of the 'asc' function using pattern matching. If 'm' is less than 'n', return an empty list. If 'm' equals 'n', return a singleton list containing 'm'. If 'm' is greater than 'n', prepend 'n' to the result of recursively calling 'asc' with 'n+1' and 'm'."
    },
    {
        "Statement": "calc (Add x y) = x+y",
        "Description": "Define the 'calc' function pattern matching on the 'Add' constructor, returning the sum of 'x' and 'y'."
    },
    {
        "Statement": "insert y [] = [y]",
        "Description": "Define the base case of the insert function where an empty list is given, it returns a list containing the element 'y'."
    },
    {
        "Statement": "using sorted.simps(2) sizeT append by blast",
        "Description": "Use the given sorted lemma to solve the subgoals."
    },
    {
        "Statement": "hn = n",
        "Description": "Assign `hn` the value of `n`."
    },
    {
        "Statement": "| otherwise    = xs",
        "Description": "Otherwise, return the remaining list."
    },
    {
        "Statement": "fun fromList (x#xs) = insert x (fromList xs)",
        "Description": "Otherwise, insert each element of the list into the tree."
    },
    {
        "Statement": "where aux ending = do",
        "Description": "Declare an auxiliary function aux that takes the ending string as an argument, and performs the following actions in the StateT monad."
    },
    {
        "Statement": "have sorted left: \"sortedT l\" using 2 sorted node by blast",
        "Description": "declare that 'l' is sorted."
    },
    {
        "Statement": "count e = foldr (\\x acc -> if e == x then acc+1 else acc) 0",
        "Description": "Define 'count' as a fold operation that counts occurrences of 'e' in a list."
    },
    {
        "Statement": "foldr1 :: (a -> a -> a) -> [a] -> a",
        "Description": "Define 'foldr1' as a function which takes a binary function and a list, and applies the function in a right-associative manner to the elements of the list, assuming that the list is non-empty."
    },
    {
        "Statement": "import Data.List (drop, take)\n\nsplitAt :: Int -> [a] -> ([a], [a])",
        "Description": "Define a function 'splitAt' that takes an index and a list of elements of any type 'a', and returns a tuple containing two lists: the first list contains the elements up to (but not including) the given index, and the second list contains the remaining elements. Import the 'drop' and 'take' functions from the 'Data.List' module."
    },
    {
        "Statement": "words' :: String -> [String]",
        "Description": "Define a function words' that takes a string s and returns a list of words by splitting s at whitespace characters."
    },
    {
        "Statement": "Lemma sets value sortedT:",
        "Description": "Define a lemma named sortedT_values."
    },
    {
        "Statement": "\"∀t1 t2. sortedT t1 ⟶ sortedT t2 ⟶ sortedT (t1 ∪ t2)\"",
        "Description": "For all trees t1 and t2, if t1 and t2 are sorted, then the union of t1 and t2 is also sorted."
    },
    {
        "Statement": "func :: Int -> Int -> Int -> Int",
        "Description": "Define a function named `func` which takes three `Int` parameters and returns an `Int`."
    },
    {
        "Statement": "return (in_lower_bound && in_upper_bound);",
        "Description": "Return true if 'x' is within the range [min, max], otherwise false."
    },
    {
        "Statement": "apply blast",
        "Description": "Use the `blast` tactic to automatically solve the generated subgoals."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the auto tactic to automatically solve the generated subgoals."
    },
    {
        "Statement": "name <- getName",
        "Description": "Call the `getName` function and bind the result (if successful) to the `name` variable."
    },
    {
        "Statement": "preOrder (Node x l r) = [x] ++ preOrder l ++ preOrder r",
        "Description": "Otherwise, return the concatenation of a singleton list containing the value at the root, the pre-order traversal of the left subtree, and the pre-order traversal of the right subtree."
    },
    {
        "Statement": "instance Eq Temperature where",
        "Description": "Declare an instance of the 'Eq' typeclass for the 'Temperature' datatype."
    },
    {
        "Statement": "empty :: Set a",
        "Description": "Declare an empty set."
    },
    {
        "Statement": "import Data.List (elemIndices)\n\nindicesOf :: Eq a => a -> [a] -> [Int]",
        "Description": "Define a function 'indicesOf' that takes an element and a list of elements of the same type 'a' that implements the 'Eq' typeclass, and returns a list of indices (zero-based) at which the element occurs in the list. Import the 'elemIndices' function from the 'Data.List' module."
    },
    {
        "Statement": "greet (Person name_) = \"Hi\" ++ name_",
        "Description": "Define 'greet' function pattern matching on 'Person' constructor with 'name_' as its argument, concatenating \"Hi\" with 'name_'."
    },
    {
        "Statement": "all :: (a -> Bool) -> Seq a -> Bool",
        "Description": "Declare a function all that checks if all elements of a sequence satisfy a predicate."
    },
    {
        "Statement": "asc :: Int -> Int -> [Int]",
        "Description": "Define a function 'asc' that generates a list of integers in ascending order."
    },
    {
        "Statement": "import Data.Maybe (catMaybes)\n\nremoveNothings :: [Maybe a] -> [a]",
        "Description": "Define a function 'removeNothings' that takes a list of 'Maybe' values of any type 'a' and returns a list containing only the 'Just' values, discarding any 'Nothing' values. Import the 'catMaybes' function from the 'Data.Maybe' module."
    },
    {
        "Statement": "get :: m s",
        "Description": "Declare a function `get` that retrieves the current state value within the base monad `m`."
    },
    {
        "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
        "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
    },
    {
        "Statement": "x :: Integer",
        "Description": "Declare a variable 'x' with type Integer."
    },
    {
        "Statement": "map :: (a -> b) -> [a] -> [b]",
        "Description": "Define a function named `map` which takes a function `(a -> b)` and a list of `a` and returns a list of `b`."
    },
    {
        "Statement": "main :: IO ()",
        "Description": "Define the 'main' function."
    },
    {
        "Statement": "by auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "nub [] = []",
        "Description": "Define the base case of the nub function where an empty list is given, it returns an empty list."
    },
    {
        "Statement": "drop _ [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "instance Monoid (Endo a) where",
        "Description": "Define a 'Monoid' instance for the 'Endo' data type."
    },
    {
        "Statement": "doubleList = map (\\x -> 2x)",
        "Description": "Define the 'doubleList' function using 'map' with a lambda function that doubles its argument."
    },
    {
        "Statement": "import Data.List (foldl')\n\nunzip' :: [(a, b)] -> ([a], [b])",
        "Description": "Define a function 'unzip'' that takes a list of pairs '(a, b)' and returns a tuple '([a], [b])' containing two lists: one with the first elements of the pairs, and one with the second elements of the pairs. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "checkInput (x:_) = isUpper x",
        "Description": "If the input string is non-empty, check if the first character is uppercase and return the result."
    },
    {
        "Statement": "maybe_val <- iom",
        "Description": "Bind the result of evaluating iom to maybe_val."
    },
    {
        "Statement": "insertionSort [] = []",
        "Description": "If the input list is empty, return an empty list."
    },
    {
        "Statement": "instance Monoid (First a) where",
        "Description": "Define a 'Monoid' instance for the 'First' data type."
    },
    {
        "Statement": "unzip ((x, y):xys) = (x:xs, y:ys)",
        "Description": "Define the recursive case of the unzip function where a non-empty list of pairs is given. It separates the first element of each pair into the first component of the resulting pair, and the second element into the second component."
    },
    {
        "Statement": "x (D3 1 2 3)",
        "Description": "Access the 'x' coordinate of a 3D point, yielding '1'."
    },
    {
        "Statement": "isPrefixOf (x:xs) (y:ys)",
        "Description": "Define the recursive case of the isPrefixOf function where two non-empty lists are given. It checks if the first list is a prefix of the second list."
    },
    {
        "Statement": "hw :: IO ()",
        "Description": "Declares the type of 'hw' as IO action that returns nothing."
    },
    {
        "Statement": "get :: m s",
        "Description": "Declare a function `get` that retrieves the current state value within the base monad `m`."
    },
    {
        "Statement": "where aux ending = do",
        "Description": "Begin the definition of the `aux` function using the do notation for monadic computations. The `aux` function takes the `ending` string as an argument."
    },
    {
        "Statement": "seq a b = b",
        "Description": "Define the seq function to return its second argument."
    },
    {
        "Statement": "\"sortedT t = sorted (inorder t)\"",
        "Description": "Define sortedT as a function that checks if the tree is sorted by using the inorder traversal."
    },
    {
        "Statement": "  where (xs, ys) = unzip xys",
        "Description": "Use recursion to continue the process."
    },
    {
        "Statement": "fun fromList :: \"('a :: linorder) list → 'a Tree\"",
        "Description": "Define a function named `fromList` which takes a list of type `('a :: linorder)` and returns a `Tree 'a`."
    },
    {
        "Statement": "instance Monoidal [] where",
        "Description": "Define a 'Monoidal' instance for the list type constructor '[]'."
    },
    {
        "Statement": "main = do catch failing (\\e -> do putStrLn \"Something went wrong!\")",
        "Description": "Define the main function to catch any exceptions of type MyError thrown by failing, and print a message \"Something went wrong!\" if an exception is caught."
    },
    {
        "Statement": "]",
        "Description": "End of the list."
    },
    {
        "Statement": "unwords (w:ws) = w ++ \" \" ++ unwords ws",
        "Description": "Define the recursive case of the unwords function where a list of words is given. It joins the first word with a space and then recursively processes the rest of the list."
    },
    {
        "Statement": "cycle :: [a] -> [a]",
        "Description": "Define a function named `cycle` which takes a list of any type and returns a list of the same type."
    },
    {
        "Statement": "shuffleString :: String -> IO String",
        "Description": "Define a function shuffleString that takes a String and shuffles its characters randomly."
    },
    {
        "Statement": "execStateT :: Monad m => StateT s m a -> s -> m s",
        "Description": "Declare a function `execStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the final state `s` (discarding the result value)."
    },
    {
        "Statement": "removeDuplicates = nub",
        "Description": "The implementation of 'removeDuplicates' simply applies the 'nub' function, which removes duplicate elements from the input list."
    },
    {
        "Statement": "(<>) a _ = a",
        "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Last a' to handle the case where the last value is 'Nothing'."
    },
    {
        "Statement": "height :: Tree a -> Int",
        "Description": "Define a function named height which takes a Tree of elements of type a and returns the height of the tree as an Int."
    },
    {
        "Statement": "sum [] = 0",
        "Description": "The base case for summing an empty list, which returns 0."
    },
    {
        "Statement": "minimum (x:xs) = min x (minimum xs)",
        "Description": "Otherwise, return the minimum of the first element and the minimum of the rest of the list."
    },
    {
        "Statement": "class (Order a) => Linorder a where {",
        "Description": "Define a class 'Linorder' with type variable 'a' which is a subclass of 'Order', where,"
    },
    {
        "Statement": "x:xs",
        "Description": "Represent a list where 'x' is the first element and 'xs' is the rest of the list."
    },
    {
        "Statement": "zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]",
        "Description": "Define 'zipWith' as a function which takes a function and two lists, and returns a list of the results of applying the function to each pair of corresponding elements."
    },
    {
        "Statement": "where aux ending count = do",
        "Description": "Declare an auxiliary function aux that takes the ending string and a count as arguments, and performs the following actions in the IO monad."
    },
    {
        "Statement": "unfoldr :: (b -> Maybe (a, b)) -> b -> [a]",
        "Description": "Define a function unfoldr that takes a function f, an initial value x, and generates a list by repeatedly applying f to the current value and using the result to generate the next value, until f returns Nothing."
    },
    {
        "Statement": "liftIOm io :: io >>= returnIOM",
        "Description": "Implement the liftIOm function by binding the result of the IO computation io to the returnIOM function, which wraps the value in a successful IOMaybe computation."
    },
    {
        "Statement": "addTuples :: [(Int, Int)] -> [Int]",
        "Description": "Define a function 'addTuples' that takes a list of tuples of integers and returns a list of integers."
    },
    {
        "Statement": "\"[]\" ([] :: [A])",
        "Description": "Declare the constant '[]' as an empty list."
    },
    {
        "Statement": "    | y == x = xs",
        "Description": "Define the condition for the recursive case of the delete function. If the element 'y' is equal to the current element 'x', it returns the rest of the list."
    },
    {
        "Statement": "case (Cons x xs)",
        "Description": "If the case is a non-empty list."
    },
    {
        "Statement": "foldr :: (a -> b -> b) -> b -> Seq a -> b",
        "Description": "Declare a function foldr that folds a sequence from the right with a binary function."
    },
    {
        "Statement": "delete _ [] = []",
        "Description": "Define the case of the delete function where an empty list is given, it returns an empty list."
    },
    {
        "Statement": "unlines :: [String] -> String",
        "Description": "Define 'unlines' as a function which joins lines, after appending a terminating newline to each."
    },
    {
        "Statement": "zip (x:xs) (y:ys) = (x, y) : zip xs ys",
        "Description": "Otherwise, pair corresponding elements of the two lists."
    },
    {
        "Statement": "topologicalSort nodes = map (nodes !!) (topSort (toGraph nodes))",
        "Description": "Implement 'topologicalSort' by converting the node list into a graph, performing a topological sort using 'topSort', and then mapping the indices back to the original node list."
    },
    {
        "Statement": "elemIndex y (x:xs)",
        "Description": "Define the recursive case of the elemIndex function where a non-empty list is given. It checks if the element 'y' is equal to the current element 'x', if so, it returns Just 0, otherwise, it recursively searches in the rest of the list."
    },
    {
        "Statement": "map [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "loop (Kleisli f) = Kleisli (liftM fst . mfix . f')",
        "Description": "Define the loop function for the Arrowloop instance of Kleisli m, which applies the mfix function to a modified version of the original function f, and then lifts the first component of the result using liftM fst."
    },
    {
        "Statement": "return input",
        "Description": "If the guard condition is satisfied, return the `input` value as the result of the `getName` computation."
    },
    {
        "Statement": "assumes",
        "Description": "Specify assumptions for the lemma."
    },
    {
        "Statement": "sum (splice xs ys) =?= sum xs + sum ys",
        "Description": "Verify whether the sum of splicing two lists xs and ys is equal to the sum of the individual lists xs and ys."
    },
    {
        "Statement": "sortedSig :: [Sig)",
        "Description": "Define 'sortedSig' as a list of Sig."
    },
    {
        "Statement": "length (_:xs) = 1 + length xs",
        "Description": "Define the length of a list as 1 plus the length of the rest of the list."
    },
    {
        "Statement": "nodeIndex (Node _ _) = error \"nodeIndex: not implemented\"",
        "Description": "Define a placeholder function 'nodeIndex' that throws an error, as its implementation is not provided in this example."
    },
    {
        "Statement": "returnIOM :: a -> IOMaybe a",
        "Description": "Define a function returnIOM that takes a value of type a and returns a successful IOMaybe computation with that value."
    },
    {
        "Statement": "newtype Endo a = Endo { appEndo :: a -> a }",
        "Description": "Define a new data type called 'Endo' with a single constructor 'Endo' that wraps a function of type 'a -> a'. The 'appEndo' function applies the wrapped function to an argument of type 'a'."
    },
    {
        "Statement": "abbreviation sortedT :: \"('a :: linorder) Tree → bool*\"",
        "Description": "Define an abbreviation named sortedT which takes a Tree of type ('a :: linorder) and returns a bool."
    },
    {
        "Statement": "fac :: Int -> Int",
        "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
    },
    {
        "Statement": "instance Monad IO",
        "Description": "Create an instance of the Monad typeclass for the IO data type, which represents computations that can perform side effects."
    },
    {
        "Statement": "propRev xs = reverse xs === rev xs",
        "Description": "Define a property named propRev that checks if reversing a list xs using the reverse function is equal to reversing it using the custom rev function."
    },
    {
        "Statement": "lemma tree_exists:",
        "Description": "Define a lemma named tree_exists."
    },
    {
        "Statement": "splice xs [] = xs",
        "Description": "Define the splice function for a non-empty list xs and an empty list to return the list xs."
    },
    {
        "Statement": "map :: (a -> b) -> [a] -> [b]",
        "Description": "Define a function named `map` which takes a function `(a -> b)` and a list of `a` and returns a list of `b`."
    },
    {
        "Statement": "newtype All a = All { getAll :: a }",
        "Description": "Define a new data type called 'All' with a single constructor 'All' that wraps a value of type 'a'. The 'getAll' function extracts the value of type 'a' from the 'All' constructor."
    },
    {
        "Statement": "         in l : case s' of",
        "Description": "Define the recursive case of the lines function. It adds the line to the result and processes the remaining string."
    },
    {
        "Statement": "safeHead :: [a] -> Maybe a",
        "Description": "Define a function 'safeHead' that takes a list and returns the first element of the list wrapped in a 'Maybe' value, or 'Nothing' if the list is empty."
    },
    {
        "Statement": "import Data.List",
        "Description": "Import the Data.List module which provides list manipulation functions."
    },
    {
        "Statement": "foldl' f z (x:xs) = let z' = f z x in z' 'seq' foldl' f z' xs",
        "Description": "Define the recursive case for foldl', which applies the function f to the initial value z and the head of the list x to get z', evaluates z' strictly using seq, and then recursively calls foldl' with z' as the new initial value and the remaining list xs."
    },
    {
        "Statement": "mergeUnique xs ys = union xs ys",
        "Description": "The implementation of 'mergeUnique' simply applies the 'union' function to the two input lists 'xs' and 'ys'."
    },
    {
        "Statement": "unzip ((x,y):xys) = (x:xs, y:ys)",
        "Description": "Otherwise, separate the first and second elements of each pair into two separate lists."
    },
    {
        "Statement": "splice [] [] = []",
        "Description": "The base case for splicing two empty lists, which returns an empty list."
    },
    {
        "Statement": "fac :: Int -> Int",
        "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
    },
    {
        "Statement": "treeToSeq (Node x l r) = treeToSeq l >< singleton x >< treeToSeq r",
        "Description": "For a non-empty tree, recursively convert the left and right subtrees into sequences, and concatenate them with the current node's value in the middle."
    },
    {
        "Statement": "f (Right \"Hello\")",
        "Description": "Applies 'f' to a 'Right' value with 'Hello', resulting in 'Hello'."
    },
    {
        "Statement": "map f (x:xs) = f x : map f xs",
        "Description": "Otherwise, apply function `f` to the first element `x` and recursively apply `map` to the rest of the list."
    },
    {
        "Statement": "listCase :: [a] -> Either () (a, [a])\nlistCase [] = Left ()\nlistCase (x:xs) = Right (x, xs)",
        "Description": "Define a function 'listCase' that takes a list and returns either an empty tuple '()' (for the empty list) or a pair containing the head and tail of the list."
    },
    {
        "Statement": "f :: Ord a => [a] -> [a]",
        "Description": "Specify the type of f to be a function taking a list of Ord type a and returning a list of the same type."
    },
    {
        "Statement": "($!) :: (a -> b) -> a -> b",
        "Description": "Define the type signature for the ($!) operator, which takes a function (a -> b) and a value of type a, and returns a value of type b."
    },
    {
        "Statement": "then show ?thesis using False sets_value_sortedT sorted_left sorted_right tv_disjunct \"2.IH\" (2) by auto",
        "Description": "then show the thesis using the given data and the assumed statement."
    },
    {
        "Statement": "readUntilWithCount :: String -> IO Int",
        "Description": "Declare a function named `readUntilWithCount` that takes a `String` argument and returns an `IO Int` computation, which reads input from the user until a specific ending string is entered and returns the number of lines read."
    },
    {
        "Statement": "toLowerString :: String -> String",
        "Description": "Define a function toLowerString that takes a String and converts it to lowercase."
    },
    {
        "Statement": "con \"sortBy\" (sortBy :: (a -> a -> Ordering) -> [a] -> [a]),",
        "Description": "Include the 'sortBy' function signature."
    },
    {
        "Statement": "foldr (\\elem acc -> <term>) <start_acc> <list>",
        "Description": "Define a fold operation where the function takes an element and an accumulator as arguments, starting with an initial accumulator value, and folding from the right over the list."
    },
    {
        "Statement": "data DataType = A | B | C\nimport Module (dataType(...))",
        "Description": "Define a data type 'DataType' with constructors 'A', 'B', and 'C'. Then imports only the specified data type constructors from the module 'Module'."
    },
    {
        "Statement": "getName :: MaybeT IO String",
        "Description": "Declare a function named `getName` that returns a `MaybeT IO String` value, which represents a computation that may fail to produce a `String` value within the `IO` monad."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to automatically solve the generated subgoals."
    },
    {
        "Statement": "failing = do throw Error",
        "Description": "Define the failing function to throw an exception of type Error."
    },
    {
        "Statement": "f :: Int -> Int -> Int\nf x y = y + square x",
        "Description": "Define a function f that takes two integers x and y, computes the square of x using the square function, and returns the sum of y and the square of x."
    },
    {
        "Statement": "getName = do",
        "Description": "Begin the implementation of the getName function using the do notation."
    },
    {
        "Statement": "get :: m s",
        "Description": "Declare a function `get` that retrieves the current state value within the base monad `m`."
    },
    {
        "Statement": "returnIOM = return . Just",
        "Description": "Implement the returnIOM function by composing the Just constructor with the return function from the Monad typeclass."
    },
    {
        "Statement": "foldl :: (a -> b -> a) -> a -> Seq b -> a",
        "Description": "Declare a function foldl that folds a sequence from the left with a binary function."
    },
    {
        "Statement": "class Functor (f :: * -> *) where",
        "Description": "Define a type class 'Functor' with a kind constraint '(* -> *)' representing type constructors that take one type argument."
    },
    {
        "Statement": "returnIOM = return . Just",
        "Description": "Implement the returnIOM function by composing the Just constructor with the return function from the Monad typeclass."
    },
    {
        "Statement": "execStateT :: Monad m => StateT sm a -> s -> m s",
        "Description": "Declare a function execStateT that takes a StateT computation and an initial state, and returns a monadic computation that produces the final state, discarding the final result."
    },
    {
        "Statement": "lookup _ Leaf = Nothing",
        "Description": "For a leaf node, return 'Nothing' since there are no subtrees."
    },
    {
        "Statement": "splice xs [] = xs",
        "Description": "Define the splice function for a non-empty list xs and an empty list to return the list xs."
    },
    {
        "Statement": "readUntilWithCount :: String -> IO Int",
        "Description": "Declare a function readUntilWithCount that takes a String argument and returns an IO Int value."
    },
    {
        "Statement": "splice [] ys = ys",
        "Description": "Define the splice function for an empty list and a non-empty list ys to return the list ys."
    },
    {
        "Statement": "then show ?case by simp",
        "Description": "then show the current case."
    },
    {
        "Statement": "aux acc\n0] = асс",
        "Description": "If the accumulator is an empty list, return the accumulator."
    },
    {
        "Statement": "module Monads",
        "Description": "Define a module named Monads."
    },
    {
        "Statement": "class Semigroup a => Monoid a where\n  mempty :: a\n  mappend :: a -> a -> a\n  mconcat :: [a] -> a",
        "Description": "Define a class Monoid that represents types that have a Semigroup instance and an identity element mempty, with a binary operation mappend and a function mconcat that combines a list of elements using the binary operation."
    },
    {
        "Statement": "import Data.List (elemIndex)",
        "Description": "Import the 'elemIndex' function from the Data.List module, which returns the index of the first occurrence of an element in a list, or 'Nothing' if the element is not found."
    },
    {
        "Statement": "in_range min max x = ilb && iub",
        "Description": "Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x', and returns whether 'x' is within the range [min, max]."
    },
    {
        "Statement": "wordCount = length . words",
        "Description": "Define 'wordCount' as a composition of the 'words' function (which splits a string into a list of words) and the 'length' function (which returns the length of the list)."
    },
    {
        "Statement": "quicksort [] = []",
        "Description": "For an empty list, 'quicksort' returns an empty list."
    },
    {
        "Statement": "(Just v) -> f v",
        "Description": "If maybe_val is Just v, apply the function f to the value v and return the resulting IOMaybe computation."
    },
    {
        "Statement": "in_range min max x = x >= min && x <= max",
        "Description": "Checks if the value of x is within the range specified by min and max"
    },
    {
        "Statement": "    | otherwise = find p xs",
        "Description": "Define the condition for the recursive case of the find function. If the predicate 'p' is not satisfied by the current element 'x', it recursively searches in the rest of the list."
    },
    {
        "Statement": "dropWhile' :: (a -> Bool) -> [a] -> [a]",
        "Description": "Define a function dropWhile' that takes a predicate p and a list xs, and returns the suffix of xs after the longest prefix that satisfies p."
    },
    {
        "Statement": "lemma \"mirror (mirror t) = t\"",
        "Description": "Define a lemma asserting that mirroring a mirrored tree results in the original tree."
    },
    {
        "Statement": "instance (Monoid w, Monad m) => MonadWriter w (ReaderT r m) where\n    tell _ = return ()\n    listen (ReaderT m) = ReaderT $ \\r -> do\n        (a, w) <- listen (m r)\n        return ((a, w), w)\n    pass (ReaderT m) = ReaderT $ \\r -> do\n        (a, f) <- pass (m r)\n        return (a, f)",
        "Description": "Provide an instance of the 'MonadWriter' type class for the 'ReaderT' monad transformer, assuming that 'm' is an instance of the 'Monad' type class and 'w' is an instance of the 'Monoid' type class. This instance allows for working with computations that produce a log along with a value within the 'ReaderT' monad transformer."
    },
    {
        "Statement": "| × < y = Z",
        "Description": "If `x * y` is less than `y`, return `Z`."
    },
    {
        "Statement": "minimum' :: Ord a => [a] -> a",
        "Description": "Define a function minimum' that takes a non-empty list xs and returns the minimum element of xs."
    },
    {
        "Statement": "if checkInput input",
        "Description": "Check if the input satisfies the checkInput condition."
    },
    {
        "Statement": "splice xs [] = xs",
        "Description": "Define the splice function for a non-empty list xs and an empty list to return the list xs."
    },
    {
        "Statement": "1:2:3:4:5: []",
        "Description": "Construct a list with integers 1 through 5 using the cons operator (:). Each element is separated by the cons operator, and the list is terminated with an empty list."
    },
    {
        "Statement": "sortBy cmp (x:xs) = sortBy cmp (filter (\\y -> cmp y x == LT) xs) ++ [x] ++ sortBy cmp (filter (\\y -> cmp y x /= LT) xs)",
        "Description": "Define the recursive case of the sortBy function where a non-empty list is given. It sorts the list using the comparison function 'cmp'."
    },
    {
        "Statement": "case (Cons x xs)",
        "Description": "If the case is a non-empty list."
    },
    {
        "Statement": "Nil >>= _ = Nil",
        "Description": "If the input to the bind operation is Nil, return Nil."
    },
    {
        "Statement": "\"sortedT t A t = (Node l v r) → sortedT 1 A sortedT r\"",
        "Description": "If the tree t is sorted, then for every Node l v r, l and r are sorted."
    },
    {
        "Statement": "dropWhile p (x:xs)",
        "Description": "Define the recursive case of the dropWhile function where a non-empty list is given. It removes elements from the list while the predicate 'p' holds true."
    },
    {
        "Statement": "take :: Int -> [a] -> [a]",
        "Description": "Define a function named `take` which takes an `Int` and a list of any type and returns a list of the same type."
    },
    {
        "Statement": "factorial n = product [1..n]",
        "Description": "Calculate the factorial of the input integer `n` using a list comprehension and the `product` function."
    },
    {
        "Statement": "delete :: a -> Set a -> Set a",
        "Description": "Declare a function delete that removes an element from a set."
    },
    {
        "Statement": "newtype StateT s (m :: _\\->_ ) a",
        "Description": "Declare a new type constructor StateT that takes two type parameters: s (representing the state) and m (representing a monad), and returns a new type a."
    },
    {
        "Statement": "fibonacci 1 = 1",
        "Description": "The Fibonacci of 1 is 1."
    },
    {
        "Statement": "import Data.Char (isDigit)\n\ncountDigits :: String -> Int",
        "Description": "Define a function 'countDigits' that takes a string and returns the count of digits in the string. Import the 'isDigit' function from the 'Data.Char' module."
    },
    {
        "Statement": "data Person = person {name :: String, age :: Int}",
        "Description": "Define a datatype 'Person' with record syntax having fields 'name' of type 'String' and 'age' of type 'Int'."
    },
    {
        "Statement": "import Data.List (subsequences)\n\nsubsequences' :: [a] -> [[a]]",
        "Description": "Define a function 'subsequences'' that takes a list of elements of any type 'a' and returns a list of all subsequences (segments in any order) of the input list, including the empty list and the input list itself. Import the 'subsequences' function from the 'Data.List' module."
    },
    {
        "Statement": "func :: Int -> Int -> Int -> Int",
        "Description": "Define a function named `func` which takes three `Int` parameters and returns an `Int`."
    },
    {
        "Statement": "abbreviation contains :: \"('a ⇒ bool) ⇒ 'a list ⇒ bool\"",
        "Description": "Define an abbreviation named `contains` which takes a function `('a ⇒ bool)` and a list of type `'a` and returns a `bool` indicating whether the element is in the list."
    },
    {
        "Statement": "prop a b = (a+b) == (b+a)",
        "Description": "Define a property named prop that checks if the sum of two numbers a and b is equal to the sum of b and a."
    },
    {
        "Statement": "import Data.Char (isSpace)\n\nsplitWords :: String -> [String]",
        "Description": "Define a function 'splitWords' that takes a string and returns a list of words (substrings separated by whitespace). Import the 'isSpace' function from the 'Data.Char' module."
    },
    {
        "Statement": "put (count + 1)",
        "Description": "Update the state by incrementing the current count by 1 and storing the new value using the `put` function."
    },
    {
        "Statement": "reverse :: Seq a -> Seq a",
        "Description": "Declare a function reverse that reverses the elements of a sequence."
    },
    {
        "Statement": "(\\x y z -> x+y+z) 1 2 3",
        "Description": "Applly the anonymous function (\\x y z -> x+y+z) to the values 1, 2, and 3, resulting in 6."
    },
    {
        "Statement": "where",
        "Description": "Begin the definition of helper functions for 'mergeSort'."
    },
    {
        "Statement": "n == 0 =1",
        "Description": "If `n` is equal to 0, return 1."
    },
    {
        "Statement": "zipWith3' :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]",
        "Description": "Define a function zipWith3' that takes a function f and three lists xs, ys, and zs, and returns a new list containing the result of applying f to each triple of elements from xs, ys, and zs."
    },
    {
        "Statement": "foldl' :: (a -> b -> a) -> a -> [b] -> a",
        "Description": "Define a function foldl' that takes a function f, an initial value z, and a list xs, and applies f to each element of xs, starting with the initial value z and the first element of xs, and then applying f to the result and the second element, and so on."
    },
    {
        "Statement": "elem' :: Eq a => a -> [a] -> Bool",
        "Description": "Define a function elem' that takes an element x and a list xs, and returns True if x is an element of xs, otherwise False."
    },
    {
        "Statement": "fac :: Int -> Int",
        "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
    },
    {
        "Statement": "concat :: [[a]] -> [a]",
        "Description": "Define 'concat' as a function which concatenates a list of lists into a single list."
    },
    {
        "Statement": "(<**>) mf mx = fmap (\\(f,x) -> f x) (mf ** mx)",
        "Description": "Define the '(<**>)' operator for the 'Monoidal' type class by applying the functions in 'mf' to the values in 'mx' using the '(**)' operator and 'fmap'."
    },
    {
        "Statement": "import Data.List (foldl')\n\nmap' :: (a -> b) -> [a] -> [b]",
        "Description": "Define a function 'map'' that takes a function 'f :: a -> b' and a list of elements of type 'a', and returns a list containing the results of applying 'f' to each element of the input list. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "partition p (x:xs)",
        "Description": "Define the recursive case of the partition function where a non-empty list is given. It separates the list into two lists: one containing the elements that satisfy the predicate and the other containing the elements that do not."
    },
    {
        "Statement": "unzip :: Seq (a, b) -> (Seq a, Seq b)",
        "Description": "Declare a function unzip that splits a sequence of pairs into two sequences."
    },
    {
        "Statement": "con \"logicalAnd\" ((&&) :: Bool -> Bool -> Bool),",
        "Description": "Include the 'logicalAnd' function signature."
    },
    {
        "Statement": "| × < y = Z",
        "Description": "If `x * y` is less than `y`, return `Z`."
    },
    {
        "Statement": "import Data.List (foldl')\n\nproductInts :: [Int] -> Int",
        "Description": "Define a function 'productInts' that takes a list of integers and returns their product. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "import Data.List (nub)\n\nremoveDuplicates :: Ord a => [a] -> [a]",
        "Description": "Define a function 'removeDuplicates' that takes a list of elements of any type 'a' that implements the 'Ord' typeclass, and returns a list of unique elements. Import the 'nub' function from the 'Data.List' module."
    },
    {
        "Statement": "treeToSeq :: Tree a -> Seq a",
        "Description": "Define a function 'treeToSeq' that converts a binary tree of type 'Tree a' into a sequence ('Seq a') while preserving the order of elements."
    },
    {
        "Statement": "asc 1 3",
        "Description": "Call the 'asc' function with arguments 1 and 3, resulting in the list [1,2,3]."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Read a line of input from the user and bind it to input."
    },
    {
        "Statement": "splice [] ys = ys",
        "Description": "If the first list is empty, return the second list ys as the result of splicing."
    },
    {
        "Statement": "Lemma sets value sizeT:",
        "Description": "Define a lemma named sizeT_values."
    },
    {
        "Statement": "sort :: Ord a => Seq a -> Seq a",
        "Description": "Declare a function sort that sorts the elements of a sequence."
    },
    {
        "Statement": "class Category (cat :: k -> k -> *) where\n  id :: forall (a :: k). cat a a\n  (.) :: forall (b :: k) (c :: k) (a :: k).\n         cat b c -> cat a b -> cat a c\n  (>>>) :: Category cat => cat a b -> cat b c -> cat a b -> cat a c\n  f >>> g = g . f",
        "Description": "Define a type class 'Category' parameterized by 'cat', which is a higher-kinded type constructor that takes two type arguments and returns a type. The 'Category' class specifies the methods 'id' (identity arrow), '.' (arrow composition), and '>>>' (right-to-left arrow composition)."
    },
    {
        "Statement": "scanr' :: (a -> b -> b) -> b -> [a] -> [b]",
        "Description": "Define a function scanr' that takes a function f, an initial value z, and a list xs, and returns a list of successive reduced values from the right, starting with the initial value z."
    },
    {
        "Statement": "instance Num a => Semigroup (Sum a) where",
        "Description": "Define a 'Semigroup' instance for the 'Sum' data type, constrained by the 'Num' type class constraint on 'a'."
    },
    {
        "Statement": "exitWith :: ExitCode -> IO a",
        "Description": "Define a function 'exitWith' which takes an ExitCode and performs an IO action that terminates the program with the specified exit code."
    },
    {
        "Statement": "instance Monoid a => Applicative ((,) a) where\n    pure x = (mempty, x)\n    (u, f) <*> (v, x) = (u `mappend` v, f x)\n    (*>) = (>>)\n    (<*) = const",
        "Description": "Provide an instance of the 'Applicative' type class for the tuple type constructor '(,) a', assuming that 'a' is an instance of the 'Monoid' type class. This instance allows for applying and combining computations."
    },
    {
        "Statement": "ilb = min <= x",
        "Description": "Check if 'x' is greater than or equal to 'min' and assign the result to 'ilb'."
    },
    {
        "Statement": "import qualified Lib",
        "Description": "Import the 'Lib' module qualified."
    },
    {
        "Statement": "                  Just (a, b') -> a : unfoldr f b'",
        "Description": "Define the 'unfoldr' function. If the result of 'f' is Just (a, b'), it adds 'a' to the result and recursively applies 'f' to 'b'."
    },
    {
        "Statement": "readUntilWithState :: String -> IO Int",
        "Description": "Declare a function named `readUntilWithState` that takes a `String` argument and returns an `IO Int` computation, which reads input from the user until a specific ending string is entered and returns the number of lines read, using the `StateT` monad transformer."
    },
    {
        "Statement": "bubbleUp x [] = [x]",
        "Description": "If the accumulator is empty, return a singleton list containing x."
    },
    {
        "Statement": "maybe_val <- iom",
        "Description": "Bind the result of the first IOMaybe computation iom to the variable maybe_val."
    },
    {
        "Statement": "main = Lib.helloworld",
        "Description": "Call the 'helloworld' function from 'Lib' when 'main' is executed."
    },
    {
        "Statement": "getName = do",
        "Description": "Begin the definition of getName by using a do block."
    },
    {
        "Statement": "getInput = do",
        "Description": "Begin the definition of getInput by using a do block."
    },
    {
        "Statement": "nub :: Eq a => [a] -> [a]",
        "Description": "Define 'nub' as a function which removes duplicate elements from a list."
    },
    {
        "Statement": "if input == ending then return () else readUntil ending",
        "Description": "Check if the input is equal to the `ending` string. If so, return the unit value `()` to indicate successful completion. Otherwise, recursively call `readUntil` with the same `ending` string."
    },
    {
        "Statement": "take n _ | n <= 0 = []",
        "Description": "If `n` is less than or equal to 0, return an empty list."
    },
    {
        "Statement": "inorder Leaf = []",
        "Description": "If the tree is empty, return an empty list."
    },
    {
        "Statement": "groupBy :: (a -> a -> Bool) -> Seq a -> Seq (Seq a)",
        "Description": "Declare a function groupBy that groups elements in a sequence using a custom equality function."
    },
    {
        "Statement": "isPrefixOf _ [] = False",
        "Description": "Define the case of the isPrefixOf function where the second list is empty, it returns False."
    },
    {
        "Statement": "lemma filter_contains: \"contains P (filter Q xs) ⟷ (contains (λx. Q x ∧ P x) xs)\"",
        "Description": "Define a lemma asserting that `P` holds for an element in the filtered list if and only if `Q` holds for that element in the original list."
    },
    {
        "Statement": "startsWith xs ys = isPrefixOf xs ys",
        "Description": "The implementation of 'startsWith' simply applies the 'isPrefixOf' function to the two input lists 'xs' and 'ys'."
    },
    {
        "Statement": "con \":>\" ((>) :: Int -> Int -> Bool),",
        "Description": "Include the ':>' operator signature."
    },
    {
        "Statement": "getName = do",
        "Description": "Begin the implementation of the getName function using the do notation."
    },
    {
        "Statement": "\"∀t1 t2. sortedT t1 ⟶ sortedT t2 ⟶ sortedT (t1 ∩ t2)\"",
        "Description": "For all trees t1 and t2, if t1 and t2 are sorted, then the intersection of t1 and t2 is also sorted."
    },
    {
        "Statement": "stimes n (Any a) = Any (a || n)",
        "Description": "Define the 'stimes' function that takes an integer 'n' and an 'Any a' value, and returns a new 'Any' value where the wrapped value 'a' is 'OR'ed 'n' times."
    },
    {
        "Statement": "right = drop (length xs `div` 2) xs",
        "Description": "Define 'right' as the second half of the list."
    },
    {
        "Statement": "frequencies [] = empty",
        "Description": "For an empty list, 'frequencies' returns an empty map."
    },
    {
        "Statement": "in_range 0 5 3",
        "Description": "Check if the value 3 is within the range [0, 5]."
    },
    {
        "Statement": "reverse [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "\"∃t. sortedT t\"",
        "Description": "There exists a tree t that is sorted."
    },
    {
        "Statement": "by (metis inorder.simps (2) sorted_append)",
        "Description": "Use the given sorted lemma to solve the subgoal."
    },
    {
        "Statement": "con \"inorder\" (inorder :: Tree OrdA -> [OrdA]),",
        "Description": "Include the 'inorder' function signature in 'treesig2'."
    },
    {
        "Statement": "newtype StateT s (m :: * -> *) a",
        "Description": "Declare a new type constructor `StateT` that represents a state transformer monad, parameterized by the state type `s`, a base monad `m`, and the result type `a`."
    },
    {
        "Statement": "sorted [x] = True",
        "Description": "If the list has one element, return True."
    },
    {
        "Statement": "quicksort [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "import Module (name1, name2)",
        "Description": "Imports only the specified entities 'name1' and 'name2' from the module 'Module' into the current namespace."
    },
    {
        "Statement": "length Nil = 0",
        "Description": "If the input list is Nil, return 0."
    },
    {
        "Statement": "zip :: [a] -> [b] -> [(a, b)]",
        "Description": "Define 'zip' as a function which takes two lists and returns a list of corresponding pairs."
    },
    {
        "Statement": "import Data.List (nub, sort)\n\nuniqueSort :: Ord a => [a] -> [a]",
        "Description": "Define a function 'uniqueSort' that takes a list of elements of any type 'a' that implements the 'Ord' typeclass, and returns a sorted list of unique elements. Import the 'nub' and 'sort' functions from the 'Data.List' module."
    },
    {
        "Statement": "lemma setT insert: \"setT (insert v t) = setT t U {v}\"",
        "Description": "Define a lemma asserting the set of a tree after inserting v is equal to the set of the original tree unioned with {v}."
    },
    {
        "Statement": "insert x [] = [x]",
        "Description": "If the input list is empty, return a singleton list containing x."
    },
    {
        "Statement": "getLine :: IO String",
        "Description": "Define an IO action 'getLine' that reads a line of input from the user and returns it as a String."
    },
    {
        "Statement": "by auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "import Data.Map (Map, empty, insert, lookup)",
        "Description": "Import the 'Map' type and related functions from the Data.Map module."
    },
    {
        "Statement": "length (Cons _ xs) = 1 + length xs",
        "Description": "Otherwise, return 1 plus the length of the tail of the list."
    },
    {
        "Statement": "newMVar :: a -> IO (MVar a)",
        "Description": "Create a new MVar with an initial value of type a."
    },
    {
        "Statement": "takeMVar :: MVar a -> IO a",
        "Description": "Take the value from the given MVar, blocking until a value is available."
    },
    {
        "Statement": "instance Semigroup a => Semigroup (Dual a) where",
        "Description": "Define a 'Semigroup' instance for the 'Dual' data type, constrained by the 'Semigroup' instance of the inner type 'a'."
    },
    {
        "Statement": "instance Monad Maybe",
        "Description": "Create an instance of the Monad typeclass for the Maybe data type, which represents computations that can either succeed with a value of type a or fail without a value."
    },
    {
        "Statement": "cross = (,)",
        "Description": "Implement the 'cross' function using the tuple constructor '(,)'."
    },
    {
        "Statement": "and' :: [Bool] -> Bool",
        "Description": "Define a function and' that takes a list of Booleans and returns True if all the elements are True, otherwise False."
    },
    {
        "Statement": "newtype Dual a = Dual { getDual :: a }",
        "Description": "Define a new data type called 'Dual' with a single constructor 'Dual' that wraps a value of type 'a'. The 'getDual' function extracts the value of type 'a' from the 'Dual' constructor."
    },
    {
        "Statement": "reverseString = reverse",
        "Description": "Use the `reverse` function to reverse the input string."
    },
    {
        "Statement": "if input == ending then return () else readUntil ending",
        "Description": "Check if the input is equal to the `ending` string. If so, return the unit value `()` to indicate successful completion. Otherwise, recursively call `readUntil` with the same `ending` string."
    },
    {
        "Statement": "wordCount :: String -> Int",
        "Description": "Define a function 'wordCount' that takes a string and returns the number of words in the string."
    },
    {
        "Statement": "merge (x:xs) (y:ys) | x < y = x : merge xs (y:ys)",
        "Description": "If the first element of the first list is less than the first element of the second list, 'merge' prepends that element to the result of merging the remaining elements."
    },
    {
        "Statement": "zip' xs ys = foldl' (\\acc (x, y) -> acc ++ [(x, y)]) [] (zip xs ys)",
        "Description": "The implementation of 'zip'' uses 'foldl'' to fold the list of pairs '(x, y)' obtained from the built-in 'zip' function, using an anonymous function that appends each pair to the accumulator 'acc'. The initial accumulator is an empty list '[]'."
    },
    {
        "Statement": "unit :: f ()",
        "Description": "Declare the 'unit' function signature for the 'Monoidal' type class, which returns a value of type 'f ()' representing the monoidal unit."
    },
    {
        "Statement": "unlines (l:ls) = l ++ \"\\n\" ++ unlines ls",
        "Description": "Define the recursive case of the unlines function where a non-empty list is given. It joins the first line with a newline and then recursively processes the rest of the list."
    },
    {
        "Statement": "bindIOM iom f = do",
        "Description": "Begin the definition of bindIOM by using a do block."
    },
    {
        "Statement": "deriving (Eq, Ord)",
        "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'Sum' data type."
    },
    {
        "Statement": "input <- lift getLine",
        "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
    },
    {
        "Statement": "break' :: (a -> Bool) -> [a] -> ([a], [a])",
        "Description": "Define a function break' that takes a predicate p and a list xs, and returns a pair of lists, where the first list contains the longest prefix of xs that does not satisfy p, and the second list contains the remaining elements."
    },
    {
        "Statement": "add = (\\x -> (\\y -> x+y))",
        "Description": "Define the 'add' function as a composition of two lambda functions, the outer one taking 'x' and the inner one taking 'y', returning their sum."
    },
    {
        "Statement": "frequencies :: Ord a => [a] -> Map a Int",
        "Description": "Define a function 'frequencies' that takes a list of elements of type 'a' (which must be an instance of the 'Ord' typeclass) and returns a map of elements to their frequencies in the list."
    },
    {
        "Statement": "age :: Person -> Int",
        "Description": "Define a function 'age' which takes a 'Person' and returns their age."
    },
    {
        "Statement": "import Data.Char (isDigit)",
        "Description": "Import the 'isDigit' function from the Data.Char module, which checks if a character is a digit."
    },
    {
        "Statement": "import Data.List (foldl')\n\nminInts :: [Int] -> Int",
        "Description": "Define a function 'minInts' that takes a list of integers and returns the minimum value in the list. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "length :: [a] -> Int",
        "Description": "Define a function named `length` which takes a list of any type and returns an `Int`."
    },
    {
        "Statement": "otherwise = n * fac (n-1)",
        "Description": "Otherwise, return `n * fac (n-1)`."
    },
    {
        "Statement": "f c acc@(x:xs) | isSpace c = []:acc",
        "Description": "If the current character is whitespace, 'f' starts a new substring in the accumulator."
    },
    {
        "Statement": "or\nimport Module (dataType(A,C))",
        "Description": "Imports only the specified data type constructors 'A' and 'C' from the module 'Module'."
    },
    {
        "Statement": "| × < y = Z",
        "Description": "If `x * y` is less than `y`, return `Z`."
    },
    {
        "Statement": "module Monads",
        "Description": "Define a module named Monads."
    },
    {
        "Statement": "getName :: MaybeT IO String",
        "Description": "Declare a function named `getName` that returns a `MaybeT IO String` value, which represents a computation that may fail to produce a `String` value within the `IO` monad."
    },
    {
        "Statement": "greet person = \"Hi\" ++ name person",
        "Description": "Define 'greet' function to concatenate \"Hi\" with the name of the person passed as argument."
    },
    {
        "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
        "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
    },
    {
        "Statement": "otherwise = n * fac (n-1)",
        "Description": "Otherwise, return `n * fac (n-1)`."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to automatically solve the generated subgoals."
    },
    {
        "Statement": "evalStateT :: Monad m => StateT s m a -> s -> m a",
        "Description": "Declare a function `evalStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the result value `a` (discarding the final state)."
    },
    {
        "Statement": "[2x | x <- [1,2,3] ]",
        "Description": "Generate a list where each element is obtained by doubling each element of the list [1,2,3]."
    },
    {
        "Statement": "compose :: (b -> c) -> (a -> b) -> a -> c",
        "Description": "Define a function compose that takes two functions f and g, and an argument x, and returns the composition f . g of the two functions applied to x."
    },
    {
        "Statement": "stimes n (Sum a) = Sum (a * n)",
        "Description": "Define the 'stimes' function that takes an integer 'n' and a 'Sum a' value, and returns a new 'Sum' value where the wrapped value 'a' is multiplied by 'n'."
    },
    {
        "Statement": "splice [] ys = ys",
        "Description": "If the first list is empty, return the second list ys as the result of splicing."
    },
    {
        "Statement": "class (Ord a) => Preorder a where {",
        "Description": "Define a class 'Preorder' with type variable 'a' which is a subclass of 'Ord', where,"
    },
    {
        "Statement": "deriving (Eq, Ord)",
        "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'NonEmpty' data type."
    },
    {
        "Statement": "foldr (\\elem acc -> <term>) <start_acc> <list>",
        "Description": "Define a fold operation where the function takes an element and an accumulator as arguments, starting with an initial accumulator value, and folding from the right over the list."
    },
    {
        "Statement": "splice [] [] = []",
        "Description": "The base case for splicing two empty lists, which returns an empty list."
    },
    {
        "Statement": "readUntilWithState :: String -> IO Int",
        "Description": "Declare a function named `readUntilWithState` that takes a `String` argument and returns an `IO Int` computation, which reads input from the user until a specific ending string is entered and returns the number of lines read, using the `StateT` monad transformer."
    },
    {
        "Statement": "using sorted. simps(2) sorted append by blast",
        "Description": "Use the given sorted lemma to solve the subgoals."
    },
    {
        "Statement": "class Arrow a => ArrowApply (a :: _->_ -> *)\n  where\n    app :: a (a b c, b) c",
        "Description": "Define a type class 'ArrowApply' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowApply' class specifies a single method 'app' for applying an arrow to its input."
    },
    {
        "Statement": "fac :: Int -> Int",
        "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
    },
    {
        "Statement": "then show ?case",
        "Description": "then show the current case."
    },
    {
        "Statement": "sum (X : XS) = X + sum XS",
        "Description": "Define a function 'sum' that takes a non-empty list as input, where X is the head of the list and XS is the tail. It recursively calculates the sum of the elements in the list by adding the head (X) to the sum of the tail (sum XS)."
    },
    {
        "Statement": "data MyError = Error deriving Show",
        "Description": "Define a data type MyError with a single constructor Error, and derive the Show instance for it."
    },
    {
        "Statement": "runStateT :: StateT s m a -> s -> m (a, s)",
        "Description": "Declare a function `runStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning the result value `a` and the final state `s`."
    },
    {
        "Statement": "complexSig = [",
        "Description": "Assign the following list of Sig to 'complexSig'."
    },
    {
        "Statement": "capitalize [] = []",
        "Description": "If the input string is empty, return an empty string."
    },
    {
        "Statement": "using assms sorted append by fastforce",
        "Description": "Use the given sorted lemma and `fastforce` tactic to solve the subgoal."
    },
    {
        "Statement": "calc :: Calculation -> Int",
        "Description": "Define a function 'calc' which takes a 'Calculation' and returns an 'Int'."
    },
    {
        "Statement": "splice [] [] = []",
        "Description": "The base case for splicing two empty lists, which returns an empty list."
    },
    {
        "Statement": "isright :: Either a b -> Bool",
        "Description": "Define a function 'isright' that checks whether the given 'Either' value is of the 'Right' type."
    },
    {
        "Statement": "case maybe_val of",
        "Description": "Start a case expression on maybe_val."
    },
    {
        "Statement": "sum [] = 0",
        "Description": "Define the base case of the sum function where an empty list is given, it returns 0."
    },
    {
        "Statement": "withArgs args action = System.Environment.withArgs args action",
        "Description": "Implement the 'withArgs' function using 'System.Environment.withArgs'."
    },
    {
        "Statement": "con \"removeDuplicates\" (nub :: Eq a => [a] -> [a]),",
        "Description": "Include the 'removeDuplicates' function signature."
    },
    {
        "Statement": "lemma contains_append: \"contains P (xs @ ys) ⟷ (contains P xs) ∨ (contains P ys)\"",
        "Description": "Define a lemma asserting that `P` holds for an element in the concatenated list if and only if `P` holds for an element in either of the original lists."
    },
    {
        "Statement": "add = (\\x -> (\\y -> x+y))",
        "Description": "Define the 'add' function as a composition of two lambda functions, the outer one taking 'x' and the inner one taking 'y', returning their sum."
    },
    {
        "Statement": "checkInput [] = False",
        "Description": "If the input String is empty, return False."
    },
    {
        "Statement": "import Module as NewName",
        "Description": "Imports all entities from the module 'Module' into the current namespace but renames the module to 'NewName', allowing access to its entities using the new name."
    },
    {
        "Statement": "export_Statement insert fromList inorder in Haskell module_name SortedTreel",
        "Description": "Export the functions 'insert', 'fromList', and 'inorder' in Haskell module 'SortedTreel'."
    },
    {
        "Statement": "lift $ putStrLn $ \"Your name is \" ++ name",
        "Description": "Print a message that includes the user's name, using `lift` to lift the `IO` action into the `MaybeT` monad."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the auto tactic to automatically solve the generated subgoals."
    },
    {
        "Statement": "import Data.List (find)\n\nfindElement :: Eq a => a -> [a] -> Maybe a",
        "Description": "Define a function 'findElement' that takes an element and a list of elements of the same type 'a' that implements the 'Eq' typeclass, and returns the first occurrence of the element in the list, wrapped in a 'Maybe' data type. Import the 'find' function from the 'Data.List' module."
    },
    {
        "Statement": "die msg = do { putStrLn msg; exitFailure }",
        "Description": "Implement the 'die' function to print the error message followed by exiting with failure status."
    },
    {
        "Statement": "mempty = First Nothing",
        "Description": "Define the 'mempty' value for the 'Monoid' instance of 'First a' as a 'First' value wrapping 'Nothing'."
    },
    {
        "Statement": "con \":~\" ((++) :: String -> String -> String),",
        "Description": "Include the ':~' operator signature."
    },
    {
        "Statement": "append (Cons x xs) ys = Cons x (append xs ys)",
        "Description": "Otherwise, prepend the head of the first list to the result of recursively calling append with the tail of the first list and the second list."
    },
    {
        "Statement": "(Just v) -> f v",
        "Description": "If maybe_val is Just v, apply the function f to v and return the result."
    },
    {
        "Statement": "unit :: a -> Maybe a\n\nunit x = Just x",
        "Description": "Define a function unit that takes a value x and returns Just x, representing the unit value of the Maybe functor."
    },
    {
        "Statement": "replicate n x",
        "Description": "Replicate the element `x` `n` times."
    },
    {
        "Statement": "proof (induction xs arbitrary: P)",
        "Description": "Apply induction on the list with an arbitrary predicate `P`."
    },
    {
        "Statement": "reverse Nil = Nil",
        "Description": "If the input list is Nil, return Nil."
    },
    {
        "Statement": "replicate :: Int -> a -> Seq a",
        "Description": "Declare a function replicate that creates a sequence with a specified length and the same value repeated."
    },
    {
        "Statement": "listCase :: [a] -> Either () (a, [a])\nlistCase [] = Left ()\nlistCase (x:xs) = Right (x, xs)",
        "Description": "Define a function 'listCase' that takes a list and returns either an empty tuple '()' (for the empty list) or a pair containing the head and tail of the list."
    },
    {
        "Statement": "(-) :: a -> a -> a",
        "Description": "Define the subtraction operation '-' within the 'Num' typeclass which takes two values of type 'a' and returns a value of type 'a'."
    },
    {
        "Statement": "\"assumes 'sortedT r'\"",
        "Description": "Assume that r is sorted."
    },
    {
        "Statement": "splice xs [] = xs",
        "Description": "If the second list is empty, return the first list xs as the result of splicing."
    },
    {
        "Statement": "return (if checkFirstChar name then Just name else Nothing)",
        "Description": "Check if the input satisfies the checkFirstChar condition. If it does, return the input wrapped in a Just constructor. Otherwise, return Nothing."
    },
    {
        "Statement": "instance Monad List where",
        "Description": "Define an instance of the Monad typeclass for the List data type."
    },
    {
        "Statement": "ones = 1 : ones\ntail ones\n==> 1 : ones ",
        "Description": "Define an infinite list named ones where each element is 1 followed by itself. Then, take the tail of the list ones, resulting in a list with all elements same as ones except the first one."
    },
    {
        "Statement": "instance Applicative IO where\n    pure = return\n    f <*> a = do\n        f' <- f\n        a' <- a\n        return (f' a')\n    (*>) = (>>)\n    (<*) = const",
        "Description": "Provide an instance of the 'Applicative' type class for the 'IO' data type. This instance allows for applying and combining 'IO' computations."
    },
    {
        "Statement": "con \"logicalNot\" (not :: Bool -> Bool),",
        "Description": "Include the 'logicalNot' function signature."
    },
    {
        "Statement": "else return Nothing",
        "Description": "If the condition is not satisfied, return Nothing."
    },
    {
        "Statement": "zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys",
        "Description": "Define the recursive case of the zipWith function where two non-empty lists are given. It applies the function 'f' to the first elements of each list, then recursively does the same for the rest of the lists."
    },
    {
        "Statement": "data [] a = [] | a : [a]",
        "Description": "Declare a data type [a] that represents a list of elements of type a, with two constructors: [] (representing an empty list) and (:) (representing a non-empty list by prepending an element to an existing list)."
    },
    {
        "Statement": "uncapitalize [] = []",
        "Description": "If the input string is empty, return an empty string."
    },
    {
        "Statement": "calc (Add x y) = x+y",
        "Description": "Define the 'calc' function pattern matching on the 'Add' constructor, returning the sum of 'x' and 'y'."
    },
    {
        "Statement": "returnIOM :: a -> IOMaybe a",
        "Description": "Define a function returnIOM that takes a value of type a and returns a successful IOMaybe computation with that value."
    },
    {
        "Statement": "isNumeric :: String -> Bool",
        "Description": "Define a function 'isNumeric' that takes a string and returns 'True' if the string represents a numeric value, and 'False' otherwise."
    },
    {
        "Statement": "safeHeadOr :: a -> [a] -> a",
        "Description": "Define a function 'safeHeadOr' that takes a default value of type 'a' and a list of elements of type 'a', and returns the first element of the list or the default value if the list is empty."
    },
    {
        "Statement": "instance Monoid a => Monoid (Dual a) where",
        "Description": "Define a 'Monoid' instance for the 'Dual' data type, constrained by the 'Monoid' instance of the inner type 'a'."
    },
    {
        "Statement": "con \"insert\" (insert :: OrdA -› Tree OrdA -> Tree OrdA)",
        "Description": "Include the 'insert' function signature in 'treeSig1'."
    },
    {
        "Statement": "in_range 4 5 3",
        "Description": "Check if the value 3 is within the range [4, 5]."
    },
    {
        "Statement": "prop xs = (length $ tail xs) == ((length xs) -1)",
        "Description": "Define a property named prop that checks if the length of the tail of a list xs is equal to the length of xs minus one."
    },
    {
        "Statement": "import Data.List (foldl')\n\nsumInts :: [Int] -> Int",
        "Description": "Define a function 'sumInts' that takes a list of integers and returns their sum. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "} else {",
        "Description": "Handle the else part of the conditional Statement."
    },
    {
        "Statement": "fmap :: (a -> b) -> f a -> f b\n\n(<$>) :: (a -> b) -> f a -> f b\n\n(<\\*>) :: f (a -> b) -> (f a -> f b)",
        "Description": "Define three functions: fmap that takes a function (a -> b) and a functor f a and returns a functor f b, (<$>) that does the same thing, and (<\\*>) that takes a functor of functions f (a -> b) and a functor f a and returns a functor f b."
    },
    {
        "Statement": "readUntil ending = do",
        "Description": "Begin the definition of the `readUntil` function using the do notation for monadic computations."
    },
    {
        "Statement": "zip [] _ = []",
        "Description": "If the first list is empty, return an empty list."
    },
    {
        "Statement": "have \"insert v (Node l tv r) = Node (insert v l) tv r\" by (simp add: True)",
        "Description": "then prove the equation 'insert v (Node l tv r) = Node (insert v l) tv r'."
    },
    {
        "Statement": "con \"addToSet\" ((\\/) :: [a] -> [a] -> [a]),",
        "Description": "Include the 'addToSet' function signature."
    },
    {
        "Statement": "import qualified Prelude;",
        "Description": "Import the Prelude module qualified."
    },
    {
        "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
        "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Any a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
    },
    {
        "Statement": "insert:: forall a. (Linorder a) => a -> Tree a -> Tree a;",
        "Description": "Define a function 'insert' which takes an element of type 'a' and a 'Tree a' and returns a 'Tree a'."
    },
    {
        "Statement": "bubbleUp x (y:ys) | otherwise = x : y : ys",
        "Description": "Otherwise, prepend x and the head of the accumulator to the tail of the accumulator."
    },
    {
        "Statement": "snd :: (a,b) -> b",
        "Description": "Return the second element of a tuple."
    },
    {
        "Statement": "catch :: Exception e => IO a -> (e -> IO a) -> IO a",
        "Description": "Define the type signature for the catch function, which takes an IO action and a handler function (e -> IO a), and returns an IO action that either executes the original action or the handler if an exception of type e is thrown."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
    },
    {
        "Statement": "findIndex :: Eq a => a -> [a] -> Maybe Int",
        "Description": "Define a function 'findIndex' that takes an element of type 'a' (which must be an instance of the 'Eq' typeclass) and a list of elements of type 'a', and returns the index of the first occurrence of the element in the list wrapped in a 'Maybe' value, or 'Nothing' if the element is not found."
    },
    {
        "Statement": "if input == ending then",
        "Description": "Check if the input string is equal to the ending string."
    },
    {
        "Statement": "import Control.Exception",
        "Description": "Import the Control.Exception module."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "withArgs :: [String] -> IO a -> IO a",
        "Description": "Define a function 'withArgs' which takes a list of strings and an IO action, and executes the action with the specified arguments."
    },
    {
        "Statement": "foldr1' :: (a -> a -> a) -> Seq a -> a",
        "Description": "Declare a function foldr1' that folds a non-empty sequence strictly from the right with a binary function."
    },
    {
        "Statement": "length :: List a -> Int",
        "Description": "Define a function named length which takes a List of elements of type a and returns the length of the list as an Int."
    },
    {
        "Statement": "in_range min max x = if ilb then iub else False",
        "Description": "Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x'. It returns True if 'x' is within the range [min, max], otherwise False."
    },
    {
        "Statement": "shuffleString xs = do",
        "Description": "Begin the definition of the `shuffleString` function using the do notation for monadic computations."
    },
    {
        "Statement": "(Just v) -> f v",
        "Description": "If maybe_val is Just v, apply the function f to the value v and return the resulting IOMaybe computation."
    },
    {
        "Statement": "scanr :: (a -> b -> b) -> b -> Seq a -> Seq b",
        "Description": "Declare a function scanr that scans a sequence from the right with a binary function."
    },
    {
        "Statement": "where types = (x :: [Int], y :: [Int])",
        "Description": "Specify the types of 'x' and 'y' as lists of integers for the 'prop' function."
    },
    {
        "Statement": "foldr (\\acc elem -> <term>) <start_acc> <list>",
        "Description": "Define a fold operation where the function takes an accumulator and an element as arguments, starting with an initial accumulator value, and folding from the right over the list."
    },
    {
        "Statement": "import Data.Complex",
        "Description": "Import the Data.Complex module."
    },
    {
        "Statement": "example = runMaybeT $ do",
        "Description": "Define a value `example` by running a `MaybeT` computation using `runMaybeT`."
    },
    {
        "Statement": "(>>=) x f = join (map f x)\n\n(>>) m k = m >>= (\\\\_ -> k)\n\nreturn x = unit x",
        "Description": "Define the member functions of the Monad typeclass: (>>=) is defined in terms of join and map, (>>) is defined using (>>=) and an anonymous function, and return is defined as unit."
    },
    {
        "Statement": "| × < y = Z",
        "Description": "If `x * y` is less than `y`, return `Z`."
    },
    {
        "Statement": "import Data.Char (digitToInt)\n\nstringToInt :: String -> Int",
        "Description": "Define a function 'stringToInt' that takes a string and returns its integer representation. Import the 'digitToInt' function from the 'Data.Char' module."
    },
    {
        "Statement": "map f (x:xs) = f x : map f xs",
        "Description": "Otherwise, apply function `f` to the first element `x` and recursively apply `map` to the rest of the list."
    },
    {
        "Statement": "lefts :: [Either a b] -> [a]",
        "Description": "Define a function 'lefts' that takes a list of 'Either' values and returns a list containing only the 'Left' values."
    },
    {
        "Statement": "type IOMaybe a = IO (Maybe a)",
        "Description": "Define a new type synonym IOMaybe a that represents a computation that can perform side effects and either succeed with a value of type a or fail without a value."
    },
    {
        "Statement": "greet (Person n_) = \"Hi\" ++ n_",
        "Description": "Define 'greet' function pattern matching on 'Person' constructor with 'n_' as its argument, concatenating \"Hi\" with 'n_'."
    },
    {
        "Statement": "fibonacci :: Int -> Integer",
        "Description": "Define a function fibonacci that takes an Int and returns the nth Fibonacci number."
    },
    {
        "Statement": "bindIOM :: IOMaybe a -> (a -> IOMaybe b) -> IOMaybe b",
        "Description": "Define a function bindIOM that takes an IOMaybe a and a function from a to IOMaybe b, and returns an IOMaybe b."
    },
    {
        "Statement": "if checkInput input",
        "Description": "Check if the input satisfies the checkInput condition."
    },
    {
        "Statement": "instance Monoid (Last a) where",
        "Description": "Define a 'Monoid' instance for the 'Last' data type."
    },
    {
        "Statement": "count ‹- get",
        "Description": "Get the current count from the state and bind it to the variable count."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "case (1 v)",
        "Description": "If the case is (1 v),"
    },
    {
        "Statement": "where",
        "Description": "Begin definition of the sizeT abbreviation."
    },
    {
        "Statement": "evalState :: States a →> s -> a",
        "Description": "Declare a function evalState that takes a State computation and an initial state, and returns the final result, discarding the final state."
    },
    {
        "Statement": "and :: [Bool] -> Bool",
        "Description": "Return True if all elements in the list are True, otherwise False."
    },
    {
        "Statement": "import Control.Arrow",
        "Description": "Import the Control.Arrow module, which provides the Arrow typeclass and related functions."
    },
    {
        "Statement": "instance Exception MyError",
        "Description": "Make the MyError data type an instance of the Exception class."
    },
    {
        "Statement": "                       [] -> []",
        "Description": "Define the condition for the recursive case of the lines function. If the remaining string is empty, it returns an empty list."
    },
    {
        "Statement": "module Main where",
        "Description": "Define the module 'Main'."
    },
    {
        "Statement": "(Just x) >>= f = f x",
        "Description": "If the input to the bind operation is Just x, apply the function f to x and return the result."
    },
    {
        "Statement": "prop k v m = lookup k ((k,v): m) === Just v\n   where types = (k :: Int, v :: Int)",
        "Description": "Define a property named prop that checks if looking up a key k in a list that contains a tuple (k,v) results in Just v."
    },
    {
        "Statement": "y = True",
        "Description": "Assign the value True to the variable 'y'."
    },
    {
        "Statement": "(>>=) :: Monad m => m a -> (a -> m b) -> m b",
        "Description": "Define the bind operator (>>=) which sequences two monadic actions."
    },
    {
        "Statement": "quickSort (x:xs) = quickSort [y | y <- xs, y < x] ++ [x] ++ quickSort [y | y <- xs, y >= x]",
        "Description": "Otherwise, recursively call quickSort on the elements less than x, prepend x to the result, and append the result of recursively calling quickSort on the elements greater than or equal to x."
    },
    {
        "Statement": "sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a",
        "Description": "Declare a function sortBy that sorts the elements of a sequence using a custom comparison function."
    },
    {
        "Statement": "con \"reverseList\" (reverse :: [a] -> [a]),",
        "Description": "Include the 'reverseList' function signature."
    },
    {
        "Statement": "p n= n≥ 0",
        "Description": "Define `p` as a function that takes `n` and returns `True` if `n` is greater than or equal to 0."
    },
    {
        "Statement": "(Just v) -> f v",
        "Description": "If maybe_val is Just v, apply the function f to v and return the result."
    },
    {
        "Statement": "case maybe_val of",
        "Description": "Start a case expression on maybe_val."
    },
    {
        "Statement": "case Nil",
        "Description": "If the case is the first list being empty."
    },
    {
        "Statement": "readUntilWithCount :: String -> IO Int",
        "Description": "Declare a function readUntilWithCount that takes a String argument and returns an IO Int value."
    },
    {
        "Statement": "f (Left 1)",
        "Description": "Applies 'f' to a 'Left' value with 1, resulting in 'Number'."
    },
    {
        "Statement": "import Control.Monad",
        "Description": "Import the Control.Monad module which provides monad functionality."
    },
    {
        "Statement": "instance Monadfix m => Arrowloop (Kleisli m)",
        "Description": "Create an instance of the Arrowloop typeclass for the Kleisli m newtype, given that m is an instance of the Monadfix class."
    },
    {
        "Statement": "else return Nothing",
        "Description": "If the input is not valid, return a failed IOMaybe computation by returning Nothing."
    },
    {
        "Statement": "maybeadd :: Num b => Maybe b -> b -> Maybe b",
        "Description": "Define a function maybeadd that adds a value to a Maybe-wrapped value."
    },
    {
        "Statement": "map f (x:xs) = f x : map f xs",
        "Description": "Otherwise, apply function `f` to the first element `x` and recursively apply `map` to the rest of the list."
    },
    {
        "Statement": "map [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "runEval :: Eval a -> a",
        "Description": "Run the given Eval computation and return its result."
    },
    {
        "Statement": "con \"even\" (even :: Int -> Bool),",
        "Description": "Include the 'even' function signature."
    },
    {
        "Statement": "insertionSort (x:xs) = insert x (insertionSort xs)",
        "Description": "Otherwise, recursively call insertionSort with the tail of the list and insert the head of the list into the sorted result."
    },
    {
        "Statement": "postOrder Leaf = []",
        "Description": "If the input tree is Leaf, return an empty list."
    },
    {
        "Statement": "Just x -> f x",
        "Description": "If m is Just x, then apply the function f to the value x inside the Just constructor."
    },
    {
        "Statement": "fun insert :: \"'a :: linorder → 'a Tree → 'a Tree\"",
        "Description": "Define a function named `insert` which takes a value of type `'a :: linorder` and a `Tree 'a` and returns a `Tree 'a`."
    },
    {
        "Statement": "(\\x -> x+1) 1",
        "Description": "Applly the anonymous function (\\x -> x+1) to the value 1, resulting in 2."
    },
    {
        "Statement": "intersperse _ [] = []",
        "Description": "Define the base case of the intersperse function where an empty list is given, returning an empty list."
    },
    {
        "Statement": "words = filter (not . null) . map trim . split",
        "Description": "Define 'words' as a composition of several functions: 'split' splits the string into a list of substrings, 'map trim' trims leading and trailing whitespace from each substring, 'filter (not . null)' removes any empty substrings."
    },
    {
        "Statement": "unwords :: [String] -> String",
        "Description": "Define 'unwords' as a function which joins words with separating spaces."
    },
    {
        "Statement": "proof (induction xs arbitrary: P)",
        "Description": "Apply induction on the list with an arbitrary predicate `P`."
    },
    {
        "Statement": "proof (induction xs rule: list.induct)",
        "Description": "Apply induction on the list using the rule for the `list` type."
    },
    {
        "Statement": "con \"isPrime\" (isPrime :: Int -> Bool),",
        "Description": "Include the 'isPrime' function signature."
    },
    {
        "Statement": "    where (xs, ys) = unzip xys",
        "Description": "Define the recursive case of the unzip function. It separates the rest of the list of pairs into the first and second components of the resulting pair."
    },
    {
        "Statement": "iterate' :: (a -> a) -> a -> [a]",
        "Description": "Define a function iterate' that takes a function f and an initial value x, and returns an infinite list by repeatedly applying f to x."
    },
    {
        "Statement": "instance Num a => Monoid (Sum a) where\n  mempty = Sum 0",
        "Description": "Provide an instance of Monoid for the Sum data type, where the mempty is the Sum wrapping 0."
    },
    {
        "Statement": "isPalindrome :: String -> Bool",
        "Description": "Define a function isPalindrome that takes a String and returns True if it's a palindrome, otherwise False."
    },
    {
        "Statement": "reverse (x:xs) = reverse xs ++ [x]",
        "Description": "Otherwise, reverse the rest of the list and append the first element."
    },
    {
        "Statement": "fac :: Int -> Int",
        "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
    },
    {
        "Statement": "drop' :: Int -> [a] -> [a]",
        "Description": "Define a function drop' that takes an integer n and a list xs, and returns the list xs with the first n elements removed."
    },
    {
        "Statement": "lines \"\" = []",
        "Description": "Define the base case of the lines function where an empty string is given, it returns an empty list."
    },
    {
        "Statement": "or = foldr (||) False",
        "Description": "Define 'or' as a fold operation using the '||' operator and starting with an initial accumulator of 'False'."
    },
    {
        "Statement": "sorry",
        "Description": "Indicate the proof is skipped for now."
    },
    {
        "Statement": "postOrder (Node x l r) = postOrder l ++ postOrder r ++ [x]",
        "Description": "Otherwise, return the concatenation of the post-order traversal of the left subtree, the post-order traversal of the right subtree, and a singleton list containing the value at the root."
    },
    {
        "Statement": "putStrLn \"Please enter input: \"",
        "Description": "Print the prompt \"Please enter input: \" to the user."
    },
    {
        "Statement": "rev\n(x:xs) = rev xs ++ [x]",
        "Description": "Reverse the list."
    },
    {
        "Statement": "checkFirstChar :: String -> Bool",
        "Description": "Define a function checkFirstChar that takes a String and returns a Bool, indicating whether the first character is uppercase or not."
    },
    {
        "Statement": "readUntil :: String -> IO ()",
        "Description": "Declare a function named `readUntil` that takes a `String` argument and returns an `IO ()` computation, which reads input from the user until a specific ending string is entered."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Read a line of input from the user and bind it to the variable `input`."
    },
    {
        "Statement": "(**) as bs = [(a,b) | a <- as, b <- bs]",
        "Description": "Define the '(**)' operator for the 'Monoidal' instance of '[]' as a list comprehension that combines all pairs of elements from the two input lists 'as' and 'bs' into tuples '(a,b)'."
    },
    {
        "Statement": "splice [] ys = ys",
        "Description": "If the first list is empty, return the second list ys as the result of splicing."
    },
    {
        "Statement": "checkInput :: String -> Bool",
        "Description": "Define a function checkInput that takes a String and returns a Bool indicating whether the input is valid or not."
    },
    {
        "Statement": "name arg1 arg2 ... argn = \"<expr>",
        "Description": "Define a function named 'name' with 'n' arguments 'arg1' to 'argn' that evaluates to the expression '<expr>'."
    },
    {
        "Statement": "map [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "(>>>=) = bindIOM",
        "Description": "Define the fish operator (>>>=) as a synonym for the bindIOM function, which is a common convention in Haskell."
    },
    {
        "Statement": "less eq:: a →> a -> Bool;",
        "Description": "Define 'less' as a function which takes two arguments of type 'a' and returns a Bool."
    },
    {
        "Statement": "data Tree a = Empty | Node a (Tree a) (Tree a)",
        "Description": "Define a data type Tree a that represents a binary tree with elements of type a, where each node can have zero, one, or two children."
    },
    {
        "Statement": "ilb = min <= x",
        "Description": "Check if 'x' is greater than or equal to 'min' and assign the result to 'ilb'."
    },
    {
        "Statement": "quickSort [] = []",
        "Description": "If the input list is empty, return an empty list."
    },
    {
        "Statement": "class Monoid w => WriterMonad w (m :: * -> *) | m -> w where\n    writer :: (a, w) -> m a\n    runWriter :: m a -> (a, w)\n    tell :: w -> m ()\n    listen :: m a -> m (a, w)\n    pass :: m (a, w -> w) -> m a\n\n    writer (a, w) = do\n        tell w\n        return a\n\n    tell w = writer ((), w)\n\n    listen m = do\n        a <- m\n        w <- getWriter\n        return (a, w)\n\n    pass m = do\n        (a, f) <- m\n        writer (a, f w)\n\n    runWriter m = runState (listen m) mempty",
        "Description": "Define a type class 'WriterMonad' parameterized by 'm' and 'w', where 'w' must be an instance of the 'Monoid' type class. The 'WriterMonad' class specifies methods 'writer', 'runWriter', 'tell', 'listen', and 'pass' for working with computations that produce a log along with a value."
    },
    {
        "Statement": "unfoldr f b = case f b of",
        "Description": "Define the 'unfoldr' function with the initial seed value 'b'. It applies the function 'f' to the seed value and processes the result."
    },
    {
        "Statement": "stimes n (All a) = All (a && n)",
        "Description": "Define the 'stimes' function that takes an integer 'n' and an 'All a' value, and returns a new 'All' value where the wrapped value 'a' is 'AND'ed 'n' times."
    },
    {
        "Statement": "input <- liftIO getLine",
        "Description": "Read a line of input from the user within the `IO` monad, lifted into the `StateT` monad using `liftIO`."
    },
    {
        "Statement": "dropWhile _ [] = []",
        "Description": "Define the case of the dropWhile function where an empty list is given, it returns an empty list."
    },
    {
        "Statement": "unlines [] = \"\"",
        "Description": "Define the base case of the unlines function where an empty list is given, it returns an empty string."
    },
    {
        "Statement": "instance Applicative ((->) r) where\n    pure = const\n    f <*> g = \\x -> f x (g x)\n    (*>) = (>>)\n    (<*) = const",
        "Description": "Provide an instance of the 'Applicative' type class for the function type constructor '(->) r'. This instance allows for applying and combining computations that take a value of type 'r' as input."
    },
    {
        "Statement": "nub (x:xs) = x : nub (filter (/= x) xs)",
        "Description": "Define the recursive case of the nub function where a non-empty list is given. It adds the first element 'x' to the result and then recursively applies nub to the remaining list without the elements equal to 'x'."
    },
    {
        "Statement": "import Data.Sequence (Seq, empty, singleton, viewl, viewr, (><))",
        "Description": "Import the 'Seq' data type and related functions from the 'Data.Sequence' module, which provides a finger-tree-based sequence data structure."
    },
    {
        "Statement": "splice [] ys = ys",
        "Description": "Define the splice function for an empty list and a non-empty list ys to return the list ys."
    },
    {
        "Statement": "import Control.Exception",
        "Description": "Import the Control.Exception module."
    },
    {
        "Statement": "fromright :: b -> Either a b -> b",
        "Description": "Define a function 'fromright' that extracts the value from a 'Right' constructor or returns a default value."
    },
    {
        "Statement": "stimes n (Product a) = Product (a ^ n)",
        "Description": "Define the 'stimes' function that takes an integer 'n' and a 'Product a' value, and returns a new 'Product' value where the wrapped value 'a' is raised to the power of 'n'."
    },
    {
        "Statement": "notElem' :: Eq a => a -> [a] -> Bool",
        "Description": "Define a function notElem' that takes an element x and a list xs, and returns True if x is not an element of xs, otherwise False."
    },
    {
        "Statement": "class Functor f => Monoidal f where\n\n    unit :: f ()\n\n    (\\*\\*) :: f a -> f b -> f (a,b)",
        "Description": "Define a typeclass Monoidal that extends the Functor typeclass. It has two member functions: unit that returns a functor f () representing the unit value, and (\\*\\*) that takes two functors f a and f b and returns a functor f (a,b) representing their product."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Read a line of input from the user and bind it to the variable input."
    },
    {
        "Statement": "prop x y z = ((x <> y) <> z) === (x <> (y <> z))",
        "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'NonEmpty a' by comparing the results of two equivalent expressions involving '<>'."
    },
    {
        "Statement": "iub = max >= x",
        "Description": "Check if 'x' is less than or equal to 'max' and assign the result to 'iub'."
    },
    {
        "Statement": "bindIOM iom f = do",
        "Description": "Begin the implementation of the bindIOM function using the do notation."
    },
    {
        "Statement": "checkInput :: String -> Bool",
        "Description": "Define a function checkInput that takes a String and returns a Bool indicating whether the input is valid or not."
    },
    {
        "Statement": "lift $ putStrLn $ \"Your name is \" ++ name",
        "Description": "Print a message that includes the user's name, using `lift` to lift the `IO` action into the `MaybeT` monad."
    },
    {
        "Statement": "splice xs [] = xs",
        "Description": "If the second list is empty, return the first list xs as the result of splicing."
    },
    {
        "Statement": "add :: Int -> Int -> Int",
        "Description": "Define a function 'add' which takes two 'Int' arguments and returns an 'Int'."
    },
    {
        "Statement": "map f (x:xs) = f x : map f xs",
        "Description": "Otherwise, apply function `f` to the first element `x` and recursively apply `map` to the rest of the list."
    },
    {
        "Statement": "postOrder :: Tree a -> [a]",
        "Description": "Define a function named postOrder which takes a Tree of elements of type a and returns a list of the elements in post-order traversal order."
    },
    {
        "Statement": "prop xs = not (null xs) ==> (length $ tail xs) === ((length xs) -1)",
        "Description": "Define a property named prop that states if xs is not null, then the length of the tail of xs is equal to the length of xs minus one."
    },
    {
        "Statement": "quicksort (x:xs) = quicksort [y | y <- xs, y < x] ++ [x] ++ quicksort [y | y <- xs, y >= x]",
        "Description": "The implementation of 'quicksort' follows the standard quicksort algorithm: select a pivot element 'x', partition the remaining elements into two lists (less than 'x' and greater than or equal to 'x'), recursively sort the two partitions, and concatenate the results with the pivot element in the middle."
    },
    {
        "Statement": "factorial :: Integer -> Integer",
        "Description": "Define a function factorial that takes an Integer and returns its factorial."
    },
    {
        "Statement": "instance ArrowApply (->) where",
        "Description": "Create an instance of the ArrowApply typeclass for the function type constructor (->) that represents functions."
    },
    {
        "Statement": "instance Monad []",
        "Description": "Create an instance of the Monad typeclass for the list type constructor [], which represents computations that can return multiple values."
    },
    {
        "Statement": "treesig2 = [",
        "Description": "Assign the following list of Sig to 'treesig2'."
    },
    {
        "Statement": "| n <= 0    = []",
        "Description": "If `n` is less than or equal to 0, return an empty list."
    },
    {
        "Statement": "cycle [] = error \"empty list\"",
        "Description": "If the list is empty, return an error."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "splice [] ys = ys",
        "Description": "If the first list is empty, return the second list ys as the result of splicing."
    },
    {
        "Statement": "rev\n[] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "insertionSort :: Ord a => [a] -> [a]",
        "Description": "Define a function named insertionSort which takes a list of elements of type a, where a is an instance of the Ord typeclass, and returns a sorted list of the same elements."
    },
    {
        "Statement": "Lemma \"sorted (inorder (fromList x§) )\"",
        "Description": "State the lemma 'sorted (inorder (fromList x§))'."
    },
    {
        "Statement": "apply (induction t1)",
        "Description": "Begin the proof by induction over tree t1."
    },
    {
        "Statement": "add x y z = (x + y) : z",
        "Description": "Define the add function to add x and y, then prepend the result to list z."
    },
    {
        "Statement": "where types = (x :: Bool, y :: Bool)",
        "Description": "Specify the types of 'x' and 'y' as boolean values for the 'prop' function."
    },
    {
        "Statement": "else readUntil ending",
        "Description": "If the input is not the ending string, recursively call readUntil with the ending string."
    },
    {
        "Statement": "where aux ending = do",
        "Description": "Begin the definition of the `aux` function using the do notation for monadic computations. The `aux` function takes the `ending` string as an argument."
    },
    {
        "Statement": "con \"concatenate\" ((++) :: [a] -> [a] -> [a]),",
        "Description": "Include the 'concatenate' function signature."
    },
    {
        "Statement": "Lemma sorted node:",
        "Description": "Define a lemma named sorted_node."
    },
    {
        "Statement": "and' = foldl' (&&) True",
        "Description": "The implementation of 'and'' uses 'foldl'' to fold the input list of boolean values using the '&&' operator (logical AND) and an initial accumulator value of 'True'."
    },
    {
        "Statement": "proof (induction t rule:insert.induct)",
        "Description": "Apply induction on the tree with the rule for the 'insert' function."
    },
    {
        "Statement": "import Test.QuickCheck",
        "Description": "Import the Test.QuickCheck module."
    },
    {
        "Statement": "reverse :: [a] -> [a]",
        "Description": "Define a function named `reverse` which takes a list of any type and returns a list of the same type."
    },
    {
        "Statement": "instance Monad a => Monad ((,) a)",
        "Description": "Create an instance of the Monad typeclass for the tuple type constructor (,) a, given that a is an instance of the Monad typeclass."
    },
    {
        "Statement": "get :: m s",
        "Description": "Declare a function get that returns the current state inside a monadic context."
    },
    {
        "Statement": "splice xs [] = xs",
        "Description": "Define the splice function for a non-empty list xs and an empty list to return the list xs."
    },
    {
        "Statement": "return input",
        "Description": "If the guard condition is satisfied, return the `input` value as the result of the `getName` computation."
    },
    {
        "Statement": "revSig\n:: [Sigl",
        "Description": "Define 'revSig' as a list of Sig."
    },
    {
        "Statement": "newtype First a = First { getFirst :: Maybe a }",
        "Description": "Define a new data type called 'First' with a single constructor 'First' that wraps a 'Maybe' value of type 'a'. The 'getFirst' function extracts the 'Maybe' value of type 'a' from the 'First' constructor."
    },
    {
        "Statement": "calc (Div x y) = div x y",
        "Description": "Define the 'calc' function pattern matching on the 'Div' constructor, returning the division of 'x' by 'y'."
    },
    {
        "Statement": "    | otherwise = x : delete y xs",
        "Description": "Define the condition for the recursive case of the delete function. If the element 'y' is not equal to the current element 'x', it keeps the current element and recursively processes the rest of the list."
    },
    {
        "Statement": "then returnIOM input",
        "Description": "If the input is valid, return a successful IOMaybe computation with the input String."
    },
    {
        "Statement": "if input == ending then return () else aux ending",
        "Description": "Check if the input is equal to the `ending` string. If so, return the unit value `()` to indicate successful completion. Otherwise, recursively call `aux` with the same `ending` string."
    },
    {
        "Statement": "union :: Set a -> Set a -> Set a",
        "Description": "Declare a function union that combines two sets."
    },
    {
        "Statement": "module Main where",
        "Description": "Define the module 'Main'."
    },
    {
        "Statement": "f c acc@(x:xs) = (c:x):xs",
        "Description": "If the current character is not whitespace, 'f' prepends it to the current substring in the accumulator."
    },
    {
        "Statement": "fun mirror Leaf = Leaf",
        "Description": "If the tree is empty, return an empty tree."
    },
    {
        "Statement": "words :: String -> [String]",
        "Description": "Define a function 'words' that takes a string and returns a list of words in the string."
    },
    {
        "Statement": "instance MonadIO m => MonadIO (StateT s m) where\n    liftIO = lift . liftIO",
        "Description": "Provide an instance of the 'MonadIO' type class for the 'StateT' monad transformer, assuming that 'm' is an instance of the 'MonadIO' type class. This instance allows for lifting 'IO' computations into the 'StateT' monad transformer."
    },
    {
        "Statement": "instance Monad Maybe where",
        "Description": "Declare an instance of the Monad type class for the Maybe type."
    },
    {
        "Statement": "foldl1 :: (a -> a -> a) -> [a] -> a",
        "Description": "Define 'foldl1' as a function which takes a binary function and a list, and applies the function in a left-associative manner to the elements of the list, assuming that the list is non-empty."
    },
    {
        "Statement": "maximum' :: Ord a => [a] -> a",
        "Description": "Define a function maximum' that takes a non-empty list xs and returns the maximum element of xs."
    },
    {
        "Statement": "drop n xs | n <= 0 = xs",
        "Description": "If `n` is less than or equal to 0, return the entire list."
    },
    {
        "Statement": "maximum (x:xs) = max x (maximum xs)",
        "Description": "Otherwise, return the maximum of the first element and the maximum of the rest of the list."
    },
    {
        "Statement": "readUntilWithCount ending = aux ending 0",
        "Description": "Define the `readUntilWithCount` function by calling an auxiliary function `aux` with the `ending` string and an initial count of `0`."
    },
    {
        "Statement": "f $ x = f x",
        "Description": "Define the ($) operator to apply the function f to the value x."
    },
    {
        "Statement": "Nothing >>= _ = Nothing",
        "Description": "If the input to the bind operation is Nothing, return Nothing."
    },
    {
        "Statement": "length [] = 0",
        "Description": "Define the length of an empty list as 0."
    },
    {
        "Statement": "predicate \"sorted\" (sorted :: [OrdA] -> Bool)",
        "Description": "Include the 'sorted' predicate signature in 'treesig2'."
    },
    {
        "Statement": "| otherwise = False",
        "Description": "Otherwise, return `False`."
    },
    {
        "Statement": "where types = (x :: Endo Int, y :: Endo Int, z :: Endo Int)",
        "Description": "Specify the types of 'x', 'y', and 'z' as 'Endo' functions of integers for the 'prop' function."
    },
    {
        "Statement": "trim = f . f []",
        "Description": "Define 'trim' as a composition of 'f' applied to an empty list and then applied to the input string."
    },
    {
        "Statement": "greet (Person name_) = \"Hi\" ++ name_",
        "Description": "Define 'greet' function pattern matching on 'Person' constructor with 'name_' as its argument, concatenating \"Hi\" with 'name_'."
    },
    {
        "Statement": "main :: 10 (",
        "Description": "Define the 'main' function."
    },
    {
        "Statement": "inOrder (Node x l r) = inOrder l ++ [x] ++ inOrder r",
        "Description": "Otherwise, return the concatenation of the in order traversal of the left subtree, a singleton list containing the value at the root, and the in-order traversal of the right subtree."
    },
    {
        "Statement": "length [] = 0",
        "Description": "Define the length of an empty list as 0."
    },
    {
        "Statement": "monadd :: (Monad m, Num b) => m b -> m b -> m b",
        "Description": "Define a function `monadd` that adds two monadic values."
    },
    {
        "Statement": "(**) as bs = [(a,b) | a <- as, b <- bs]",
        "Description": "Define the '(**)' operator for the 'Monoidal' instance of '[]' as a list comprehension that combines all pairs of elements from the two input lists 'as' and 'bs' into tuples '(a,b)'."
    },
    {
        "Statement": "bindIOM iom f = do",
        "Description": "Begin the definition of bindIOM by using a do block."
    },
    {
        "Statement": "data List a = Nil | Cons a (List a)",
        "Description": "Define a data type named List which is either Nil or a Cons cell containing an element of type a and a List of the same type."
    },
    {
        "Statement": "import Data.List (nub)",
        "Description": "Import the 'nub' function from the Data.List module, which removes duplicate elements from a list."
    },
    {
        "Statement": "topMost :: TreeZipper a -> Tree a",
        "Description": "Define a function 'topMost' that returns the topmost tree from a 'TreeZipper a'."
    },
    {
        "Statement": "removeNothings = catMaybes",
        "Description": "The implementation of 'removeNothings' simply applies the 'catMaybes' function to the input list of 'Maybe' values."
    },
    {
        "Statement": "greet :: Person -> String",
        "Description": "Define a function 'greet' which takes a 'Person' and returns a greeting string."
    },
    {
        "Statement": "(<>) _ (Last (Just y)) = Last (Just y)",
        "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Last a' to prioritize the last non-Nothing value."
    },
    {
        "Statement": "rpar :: Strategy a",
        "Description": "Create a Strategy that sparks a new thread to compute the given value in parallel."
    },
    {
        "Statement": "    | y == x = Just 0",
        "Description": "Define the condition for the recursive case of the elemIndex function. If the element 'y' is equal to the current element 'x', it returns Just 0."
    },
    {
        "Statement": "import Data.List (foldl')\n\nzip' :: [a] -> [b] -> [(a, b)]",
        "Description": "Define a function 'zip'' that takes two lists of elements of types 'a' and 'b', and returns a list of pairs '(a, b)' containing the corresponding elements from the input lists. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "(<$) :: a -> f b -> f a",
        "Description": "Declare the '(<$)' operator signature for the 'Functor' type class, which takes a value of type 'a' and a value of type 'f b', and returns a value of type 'f a'."
    },
    {
        "Statement": "class Applicative m => Monad (m :: * -> *) where",
        "Description": "Declare the Monad type class, which extends the Applicative type class."
    },
    {
        "Statement": "import Test.QuickCheck.Poly(OrdA(..))",
        "Description": "Import the OrdA class from Test.QuickCheck.Poly module."
    },
    {
        "Statement": "let ncount = count + 1",
        "Description": "Calculate the new count `ncount` by incrementing the current `count` by 1."
    },
    {
        "Statement": "f a b = if a 'mod' 2 == 0 then a else b",
        "Description": "Define a function f that takes two arguments a and b, if a is even, return a, otherwise return b."
    },
    {
        "Statement": "by auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "class Arrow a => ArrowLoop (a :: _->_ -> *)\n  where\n    loop :: a (b, d) (c, d) -> a b c",
        "Description": "Define a type class 'ArrowLoop' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowLoop' class specifies a single method 'loop' for creating feedback loops."
    },
    {
        "Statement": "insert v (Node l tv r) =\n(if less eq v tv then Node (insert v l) tv r else Node l tv (insert v r));",
        "Description": "If 'v' is less than or equal to 'tv', then insert 'v' in the left subtree, else insert 'v' in the right subtree."
    },
    {
        "Statement": "insert :: Ord a => a -> Tree a -> Tree a",
        "Description": "Define a function insert that takes an element x and a binary search tree t, and inserts x into t, maintaining the ordering of the tree."
    },
    {
        "Statement": "case (Cons x xs)",
        "Description": "If the case is a non-empty list."
    },
    {
        "Statement": "splitEithers = partitionEithers",
        "Description": "The implementation of 'splitEithers' simply applies the 'partitionEithers' function to the input list of 'Either' values."
    },
    {
        "Statement": "case (Cons x xs)",
        "Description": "If the case is a non-empty first list."
    },
    {
        "Statement": "productInts = foldl' () 1",
        "Description": "The implementation of 'productInts' uses 'foldl'' to fold the input list of integers using the '' operator and an initial accumulator value of 1."
    },
    {
        "Statement": "instance Exception MyError",
        "Description": "Make the MyError data type an instance of the Exception class."
    },
    {
        "Statement": "p n= n≥ 0",
        "Description": "Define `p` as a function that takes `n` and returns `True` if `n` is greater than or equal to 0."
    },
    {
        "Statement": "n == 0 =1",
        "Description": "If `n` is equal to 0, return 1."
    },
    {
        "Statement": "instance Monad Maybe where",
        "Description": "Define an instance of the Monad typeclass for the Maybe data type."
    },
    {
        "Statement": "let x = func1 arg",
        "Description": "Define a variable 'x' which is assigned the result of calling function 'func1' with argument 'arg'."
    },
    {
        "Statement": "]",
        "Description": "End the 'treeSig1' list definition."
    },
    {
        "Statement": "data Person = person {name :: String, age :: Int}",
        "Description": "Define a datatype 'Person' with record syntax having fields 'name' of type 'String' and 'age' of type 'Int'."
    },
    {
        "Statement": "delete y (x:xs)",
        "Description": "Define the recursive case of the delete function where a non-empty list is given. It removes the first occurrence of the element 'y' from the list."
    },
    {
        "Statement": "minimum :: Ord a => Seq a -> a",
        "Description": "Declare a function minimum that returns the minimum element of a sequence."
    },
    {
        "Statement": "mempty = Sum 0",
        "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Sum a' as a 'Sum' value wrapping the number '0'."
    },
    {
        "Statement": "case Nil",
        "Description": "If the case is an empty list."
    },
    {
        "Statement": "instance Semigroup (NonEmpty a) where",
        "Description": "Define a 'Semigroup' instance for the 'NonEmpty' data type."
    },
    {
        "Statement": "tail :: [a] -> [a]",
        "Description": "Return all elements of a list except the first one."
    },
    {
        "Statement": "\"sizeT l < sizeT (Node l v r)\"",
        "Description": "Assume that the size of l is less than the size of the node."
    },
    {
        "Statement": "getName = do",
        "Description": "Begin the implementation of the getName function using the do notation."
    },
    {
        "Statement": "instance Exception MyError",
        "Description": "Make the MyError data type an instance of the Exception class."
    },
    {
        "Statement": "lemma tree_intersection:",
        "Description": "Define a lemma named tree_intersection."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the auto tactic to automatically solve the generated subgoals."
    },
    {
        "Statement": "put :: s -> m ()",
        "Description": "Declare a function `put` that takes a new state value and updates the current state within the base monad `m`."
    },
    {
        "Statement": "\"sortedT t = sorted (inorder t)\"",
        "Description": "Define `sortedT` as a function that checks if the tree is sorted by using the inorder traversal."
    },
    {
        "Statement": "where aux ending count = do",
        "Description": "Declare an auxiliary function aux that takes the ending string and a count as arguments, and performs the following actions in the IO monad."
    },
    {
        "Statement": "addSig::\n[Sig]",
        "Description": "Define 'addSig' as a list of Sig."
    },
    {
        "Statement": "import Data.List (transpose)\n\ntransposeMatrix :: [[a]] -> [[a]]",
        "Description": "Define a function 'transposeMatrix' that takes a matrix represented as a list of lists and returns its transpose. Import the 'transpose' function from the 'Data.List' module."
    },
    {
        "Statement": "import Data.List (foldl')\n\nreplicate' :: Int -> a -> [a]",
        "Description": "Define a function 'replicate'' that takes an integer 'n' and a value 'x' of any type 'a', and returns a list of length 'n' with 'x' replicated 'n' times. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "length xs =? = foldr (const (+1)) 0 xs",
        "Description": "State that the length of a list xs can be computed using the foldr function, applying the const (+1) function to each element and starting with an initial value of 0."
    },
    {
        "Statement": "readUntilWithCount :: String -> IO Int",
        "Description": "Declare a function readUntilWithCount that takes a String argument and returns an IO Int value."
    },
    {
        "Statement": "fmap :: (a -> b) -> f a -> f b",
        "Description": "Declare the 'fmap' function signature for the 'Functor' type class, which takes a function '(a -> b)' and a value of type 'f a', and returns a value of type 'f b'."
    },
    {
        "Statement": "class Functor f => Applicative (f :: * -> *) where\n    pure :: a -> f a\n    (<*>) :: f (a -> b) -> f a -> f b\n    (*>) :: f a -> f b -> f b\n    (<*) :: f a -> f b -> f a",
        "Description": "Define a type class 'Applicative' parameterized by 'f', requiring 'f' to be an instance of the 'Functor' type class. The 'Applicative' class specifies methods 'pure', '<*>', '*>', and '<*' for applying and combining computations."
    },
    {
        "Statement": "    | otherwise = fmap (+1) (elemIndex y xs)",
        "Description": "Define the condition for the recursive case of the elemIndex function. If the element 'y' is not equal to the current element 'x', it recursively searches in the rest of the list and increments the result by 1."
    },
    {
        "Statement": "readUntilWithCount :: String -> IO Int",
        "Description": "Declare a function named `readUntilWithCount` that takes a `String` argument and returns an `IO Int` computation, which reads input from the user until a specific ending string is entered and returns the number of lines read."
    },
    {
        "Statement": "intersection :: Set a -> Set a -> Set a",
        "Description": "Declare a function intersection that returns the intersection of two sets."
    },
    {
        "Statement": "splice [] ys = ys",
        "Description": "Define the splice function for an empty list and a non-empty list ys to return the list ys."
    },
    {
        "Statement": "minimum = foldl1 min",
        "Description": "Define 'minimum' as a function which finds the minimum element of a non-empty list using the 'min' function."
    },
    {
        "Statement": "x (D2 1 2)",
        "Description": "Access the 'x' coordinate of a 2D point, yielding '1'."
    },
    {
        "Statement": "instance Monad Maybe",
        "Description": "Define a Monad instance for Maybe type."
    },
    {
        "Statement": "class (Preorder a) => Order a where {",
        "Description": "Define a class 'Order' with type variable 'a' which is a subclass of 'Preorder', where,"
    },
    {
        "Statement": "if (z) {",
        "Description": "Start a conditional Statement based on the value of 'z'."
    },
    {
        "Statement": "addTuples [(1,2), (2,3), (100,100)]",
        "Description": "Call the function 'addTuples' with a list of tuples [(1,2), (2,3), (100,100)], resulting in [3,5,200]."
    },
    {
        "Statement": "topMost (TreeZipper t _ _) = t",
        "Description": "Implement 'topMost' by extracting the current subtree from the 'TreeZipper a' data structure."
    },
    {
        "Statement": "takeWhile :: (a -> Bool) -> [a] -> [a]",
        "Description": "Define a function named `takeWhile` which takes a function and a list and returns a list."
    },
    {
        "Statement": "fibonacci 0 = 0",
        "Description": "The Fibonacci of 0 is 0."
    },
    {
        "Statement": "instance MonadIO m => MonadIO (WriterT w m) where\n    liftIO = lift . liftIO",
        "Description": "Provide an instance of the 'MonadIO' type class for the 'WriterT' monad transformer, assuming that 'm' is an instance of the 'MonadIO' type class. This instance allows for lifting 'IO' computations into the 'WriterT' monad transformer."
    },
    {
        "Statement": "($) :: (a -> b) -> a -> b",
        "Description": "Define the type signature for the ($) operator, which takes a function (a -> b) and a value of type a, and returns a value of type b."
    },
    {
        "Statement": "zip' :: [a] -> [b] -> [(a, b)]",
        "Description": "Define a function zip' that takes two lists xs and ys, and returns a list of pairs, where each pair contains one element from xs and the corresponding element from ys."
    },
    {
        "Statement": "in_range :: Integer -> Integer -> Integer -> Bool",
        "Description": "Declare a function 'in_range' that takes three Integer arguments and returns a Bool."
    },
    {
        "Statement": "splitAt' :: Int -> [a] -> ([a], [a])",
        "Description": "Define a function splitAt' that takes an integer n and a list xs, and returns a pair of lists, where the first list contains the first n elements of xs, and the second list contains the remaining elements."
    },
    {
        "Statement": "Module.name",
        "Description": "Accesses the entity 'name' from the module 'Module'."
    },
    {
        "Statement": "height (Node _ l r) = 1 + max (height l) (height r)",
        "Description": "Otherwise, return 1 plus the maximum of the heights of the left and right subtrees."
    },
    {
        "Statement": "sum [] = 0",
        "Description": "The base case for summing an empty list, which returns 0."
    },
    {
        "Statement": "con \"fromist\" (fromlist:: [OrdA] -> Tree OrdA),",
        "Description": "Include the 'fromlist' function signature in 'treesig2'."
    },
    {
        "Statement": "lemma contains_filter: \"contains P (filter Q xs) ⟷ contains P xs ∧ (∃x ∈ set xs. Q x)\"",
        "Description": "Define a lemma asserting that `P` holds for an element in the filtered list if and only if `P` holds for the original list and there exists an element in the set of the original list satisfying `Q`."
    },
    {
        "Statement": "isJust :: Maybe a -> Bool",
        "Description": "Define a function 'isJust' which takes a 'Maybe' value and returns 'True' if it is a 'Just' value, otherwise returns 'False'."
    },
    {
        "Statement": "return y;",
        "Description": "Return the value of 'y' if 'z' is false."
    },
    {
        "Statement": "readUntil :: String -> IO ()",
        "Description": "Declare a function named `readUntil` that takes a `String` argument and returns an `IO ()` computation, which reads input from the user until a specific ending string is entered."
    },
    {
        "Statement": "readUntilWithCount ending = aux ending 0",
        "Description": "Define the implementation of readUntilWithCount by calling the auxiliary function aux with the ending string and an initial count of 0."
    },
    {
        "Statement": "getName :: IOMaybe String",
        "Description": "Define a function getName that returns an IOMaybe String."
    },
    {
        "Statement": "merge :: Ord a => [a] -> [a] -> [a]",
        "Description": "Define a function 'merge' that takes two sorted lists and returns a single sorted list."
    },
    {
        "Statement": "    | y == x = Just v",
        "Description": "Define the condition for the recursive case of the lookup function. If the key 'y' is found, it returns the associated value 'v'."
    },
    {
        "Statement": "intersect' function from the 'Data.List' module."
    },
    {
        "Statement": "bubbleSort [] = []",
        "Description": "If the input list is empty, return an empty list."
    },
    {
        "Statement": "checkInput :: String -> Bool",
        "Description": "Define a function checkInput that takes a String and returns a Bool indicating whether the input is valid or not."
    },
    {
        "Statement": "newtype Last a = Last { getLast :: Maybe a }",
        "Description": "Define a new data type called 'Last' with a single constructor 'Last' that wraps a 'Maybe' value of type 'a'. The 'getLast' function extracts the 'Maybe' value of type 'a' from the 'Last' constructor."
    },
    {
        "Statement": "sortBy _ [] = []",
        "Description": "Define the case of the sortBy function where an empty list is given, it returns an empty list."
    },
    {
        "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
        "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Dual a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
    },
    {
        "Statement": "instance MonadState s m => MonadState s (ReaderT r m) where\n    get = lift get\n    put = lift . put",
        "Description": "Provide an instance of the 'MonadState' type class for the 'ReaderT' monad transformer, assuming that 'm' is an instance of the 'MonadState' type class. This instance allows for working with state within the 'ReaderT' monad transformer."
    },
    {
        "Statement": "init :: [a] -> [a]",
        "Description": "Return all elements of a list except the last one."
    },
    {
        "Statement": "f :: [a] -> [a]",
        "Description": "Declare a function f which takes a list of type a and returns a list of the same type."
    },
    {
        "Statement": "contains P (x # xs) = (P x) ∨ (contains P xs)",
        "Description": "Define `contains` as a function that checks if the predicate `P` holds for the head of the list or if it's contained in the tail of the list."
    },
    {
        "Statement": "partition _ [] = ([], [])",
        "Description": "Define the base case of the partition function where an empty list is given, it returns a pair of empty lists."
    },
    {
        "Statement": "instance Arrow (->) where\n  arr = id\n  (***) f g (x,y) = (f x, g y)\n  a :: (Arrow a, Num c) => a c c\n  a = arr (+1)\n  b :: (Arrow a, Num c) => a c c\n  b = arr (*2)\n  comb :: (Arrow a, Num c ) => a (c, c) c\n  comb = arr (\\(x,y) -> x + y)\n  c :: (Arrow cat, Num c) => cat c c\n  c = a &&& b >>> comb",
        "Description": "Provide an instance of the 'Arrow' type class for the function type constructor '(->) a b'. It also defines several arrows: 'a' is an arrow that increments a number, 'b' is an arrow that doubles a number, 'comb' is an arrow that adds two numbers, and 'c' is an arrow that combines 'a' and 'b' in parallel and then adds the results using 'comb'."
    },
    {
        "Statement": "foldl' :: (a -> b -> a) -> a -> [b] -> a",
        "Description": "Define the type signature for the foldl' function, which takes a function (a -> b -> a), an initial value of type a, and a list of elements of type b, and returns a value of type a."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "import Data.Graph (Graph, buildG, topSort)",
        "Description": "Import the 'Graph' data type and related functions from the 'Data.Graph' module, which provides graph data structures and algorithms."
    },
    {
        "Statement": "instance Monad (Either e)",
        "Description": "Create an instance of the Monad typeclass for the Either e data type, which represents computations that can either succeed with a value of type a or fail with a value of type e."
    },
    {
        "Statement": "where types = (x :: [Int], y :: [Int])",
        "Description": "Specify the types of 'x' and 'y' as lists of integers for the 'prop' function."
    },
    {
        "Statement": "data MyError = Error deriving Show",
        "Description": "Define a data type MyError with a single constructor Error, and derive the Show instance for it."
    },
    {
        "Statement": "maybeadd mx my = mx >>= (\\x -> my >>= (\\y -> Just $ x+y))",
        "Description": "Use nested bind operators to sequentially extract values from `mx` and `my`, adds them, and wraps the result in a Just context."
    },
    {
        "Statement": "scanr1 :: (a -> a -> a) -> Seq a -> Seq a",
        "Description": "Declare a function scanr1 that scans a non-empty sequence from the right with a binary function."
    },
    {
        "Statement": "sizeT Leaf = 0",
        "Description": "Define sizeT for the Leaf as 0."
    },
    {
        "Statement": "complexSig :: [Sig]",
        "Description": "Define 'complexSig' as a list of Sig."
    },
    {
        "Statement": "func x = if x == 0 then ( else f (x-1))",
        "Description": "Define `func` to return `f (x-1)` if `x` is equal to 0."
    },
    {
        "Statement": "(<**>) :: Monoidal f => f (a -> b) -> f a -> f b",
        "Description": "Declare the '(<**>)' operator signature for the 'Monoidal' type class, which takes a value of type 'f (a -> b)' and a value of type 'f a', and returns a value of type 'f b' by applying the functions in the first argument to the values in the second argument."
    },
    {
        "Statement": "class Functor (f :: * -> *) where",
        "Description": "Define a type class 'Functor' with a kind constraint '(* -> *)' representing type constructors that take one type argument."
    },
    {
        "Statement": "deleteBy _ _ [] = []",
        "Description": "Define the case of the deleteBy function where an empty list is given, it returns an empty list."
    },
    {
        "Statement": "product (x:xs) = x * product xs",
        "Description": "Define the product of a list as the first element times the product of the rest of the list."
    },
    {
        "Statement": "runEval $ do\n  a <- rpar (f x)\n  b <- rseq (f y)\n  rseq a\n  rseq b\n  return (a,b)",
        "Description": "Run a parallel computation that evaluates (f x) and (f y) in parallel, and returns a pair (a, b) where a and b are the results of the parallel computations."
    },
    {
        "Statement": "let ncount = count + 1",
        "Description": "Calculate the new count `ncount` by incrementing the current `count` by 1."
    },
    {
        "Statement": "Lemma set_contains: \"(∃x ∈ set xs. P x) ⟶ contains P xs\"",
        "Description": "Define a lemma asserting that if an element is in the set of the list, then `P` holds for that element in the list."
    },
    {
        "Statement": "instance Monad m => Arrow (Kleisli m) where\n  arr f = Kleisli (return . f)\n  first (Kleisli f) = Kleisli (\\ -(b,d) -> f b >>= \\c -> return (c, d))\n  second (Kleisli f) = Kleisli (\\ -(d,b) -> f b >>= \\c -> return (d, c))\n  (***) = ...",
        "Description": "Provide an instance of the 'Arrow' type class for the 'Kleisli' newtype, assuming that 'm' is an instance of the 'Monad' type class. The instance defines the 'arr', 'first', 'second', and '***' methods for 'Kleisli' arrows."
    },
    {
        "Statement": "fromList:: forall a. (Linorder a) => [a] -> Tree a;",
        "Description": "Define a function 'fromList' which takes a list of 'a' and returns a 'Tree a'."
    },
    {
        "Statement": "map' f = foldl' (\\acc x -> acc ++ [f x]) []",
        "Description": "The implementation of 'map'' uses 'foldl'' to fold the input list using an anonymous function that appends the result of applying 'f' to the current element 'x' to the accumulator 'acc'. The initial accumulator is an empty list '[]'."
    },
    {
        "Statement": "z = 3.1415",
        "Description": "Assign the value 3.1415 to the variable 'z'."
    },
    {
        "Statement": "module DataStructures",
        "Description": "Define a module named DataStructures."
    },
    {
        "Statement": "Nothing >> Just 1",
        "Description": "Perform the (>>) operation with Nothing and Just 1, resulting in Nothing."
    },
    {
        "Statement": "func :: Int -> Int -> Int -> Int",
        "Description": "Define a function named `func` which takes three `Int` parameters and returns an `Int`."
    },
    {
        "Statement": "proof (induction xs arbitrary: n)",
        "Description": "Apply induction on the list with an arbitrary number `n`."
    },
    {
        "Statement": "take :: Int -> Seq a -> Seq a",
        "Description": "Declare a function take that returns the specified number of elements from the beginning of a sequence."
    },
    {
        "Statement": "quickSort [] = []",
        "Description": "If the input list is empty, return an empty list."
    },
    {
        "Statement": "func x = if x == 0 then ( else f (x-1))",
        "Description": "Define `func` to return `f (x-1)` if `x` is equal to 0."
    },
    {
        "Statement": "readUntilWithState :: String -> IO Int",
        "Description": "Declare a function named `readUntilWithState` that takes a `String` argument and returns an `IO Int` computation, which reads input from the user until a specific ending string is entered and returns the number of lines read, using the `StateT` monad transformer."
    },
    {
        "Statement": "findIndicesL :: (a -> Bool) -> Seq a -> Seq Int",
        "Description": "Declare a function findIndicesL that returns all indices of elements satisfying a predicate in a sequence."
    },
    {
        "Statement": "| × < y = Z",
        "Description": "If `x * y` is less than `y`, return `Z`."
    },
    {
        "Statement": "if input == ending then return () else aux ending",
        "Description": "Check if the input is equal to the `ending` string. If so, return the unit value `()` to indicate successful completion. Otherwise, recursively call `aux` with the same `ending` string."
    },
    {
        "Statement": "else return Nothing",
        "Description": "If the condition is not satisfied, return Nothing."
    },
    {
        "Statement": "imports Main",
        "Description": "Import `Main` module."
    },
    {
        "Statement": "foldl' (+) 0 [1,2,3]",
        "Description": "Perform a strict left fold using the (+) operator and initial value 0 over the list [1,2,3]."
    },
    {
        "Statement": "import Data.List",
        "Description": "Import the Data.List module which provides list manipulation functions."
    },
    {
        "Statement": "class Category a => Arrow (a :: _->_ -> *)",
        "Description": "Define a type class 'Arrow' parameterized by 'a' which must be an instance of the 'Category' type class. The 'Arrow' type is a higher-kinded type constructor that takes two type arguments and returns a type."
    },
    {
        "Statement": "case Nil",
        "Description": "If the case is an empty list."
    },
    {
        "Statement": "getName = do",
        "Description": "Begin the definition of the `getName` function using the do notation for monadic computations."
    },
    {
        "Statement": "lookup _ [] = Nothing",
        "Description": "Define the case of the lookup function where an empty list is given, it returns Nothing."
    },
    {
        "Statement": "import Data.List (foldl')\n\nand' :: [Bool] -> Bool",
        "Description": "Define a function 'and'' that takes a list of boolean values and returns their logical conjunction (AND). Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "try :: Exception e => IO a -> IO (Either e a)",
        "Description": "Create an IO action that attempts to run the given IO action, returning either an exception of type e or the result of type a, wrapped in the Either data type."
    },
    {
        "Statement": "| otherwise = func (x-y) (y*2) (z+1)",
        "Description": "Otherwise, recursively call `func` with `(x-y)`, `(y*2)`, and `(z+1)`."
    },
    {
        "Statement": "lift3 :: (a -> b -> c -> d) -> (f a -> f b -> f c -> f d)",
        "Description": "Declare the 'lift3' function signature, which takes a ternary function '(a -> b -> c -> d)' and returns a function that lifts the ternary function to operate on values of types 'f a', 'f b', and 'f c', returning a value of type 'f d'."
    },
    {
        "Statement": "data TreeZipper a = TreeZipper (Tree a) [TreePos] [TreePos]",
        "Description": "Define a data type 'TreeZipper a' that represents a zipper for navigating and modifying a tree of type 'Tree a', containing the current subtree, the path to the current subtree, and the remaining paths."
    },
    {
        "Statement": "name :: Person -> String",
        "Description": "Define a function 'name' which takes a 'Person' and returns their name."
    },
    {
        "Statement": "instance Monad IO",
        "Description": "Create an instance of the Monad typeclass for the IO data type, which represents computations that can perform side effects."
    },
    {
        "Statement": "checkInput :: String -> Bool",
        "Description": "Define a function checkInput that takes a String and returns a Bool."
    },
    {
        "Statement": "con \"gcd\" (gcd :: Int -> Int -> Int),",
        "Description": "Include the 'gcd' function signature."
    },
    {
        "Statement": "isleft :: Either a b -> Bool",
        "Description": "Define a function 'isleft' that checks whether the given 'Either' value is of the 'Left' type."
    },
    {
        "Statement": "| p x       = x : takeWhile p xs",
        "Description": "If the predicate `p` holds true for `x`, include `x` in the result."
    },
    {
        "Statement": "case Nil",
        "Description": "If the case is an empty list."
    },
    {
        "Statement": "evens [] = []",
        "Description": "Base case: If the list is empty, the result is an empty list."
    },
    {
        "Statement": "else return Nothing",
        "Description": "If the input is not valid, return a failed IOMaybe computation by returning Nothing."
    },
    {
        "Statement": "instance Semigroup (First a) where",
        "Description": "Define a 'Semigroup' instance for the 'First' data type."
    },
    {
        "Statement": "deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]",
        "Description": "Define 'deleteFirstsBy' as a function which removes the first occurrence of each element in the second list from the first list, where equality is determined by the given predicate."
    },
    {
        "Statement": "  {-# MINIMAL (>>=) #-}",
        "Description": "Specify that the bind operator is the minimal complete definition for a Monad instance."
    },
    {
        "Statement": ":> greet Hello",
        "Description": "Invoke the 'greet' function with the argument 'Hello'."
    },
    {
        "Statement": "con \"maximum\" (maximum :: [Int] -> Int),",
        "Description": "Include the 'maximum' function signature."
    },
    {
        "Statement": "bubbleUp x (y:ys) | x > y = y : bubbleUp x ys",
        "Description": "If x is greater than the head of the accumulator, prepend the head to the result of recursively calling bubbleUp with x and the tail of the accumulator."
    },
    {
        "Statement": "bubbleSort xs = bSort xs []",
        "Description": "Otherwise, call the helper function bSort with the input list xs and an empty accumulator."
    },
    {
        "Statement": "Just 1 >> Just 2",
        "Description": "Perform the (>>) operation with Just 1 and Just 2, resulting in Just 2."
    },
    {
        "Statement": "sortAndRemoveDuplicates :: Ord a => [a] -> [a]",
        "Description": "Define a function 'sortAndRemoveDuplicates' that takes a list of elements of type 'a' (which must be an instance of the 'Ord' typeclass) and returns a sorted list with duplicates removed."
    },
    {
        "Statement": "proof (cases \"v s tv\")",
        "Description": "Apply proof by cases on 'v s tv'."
    },
    {
        "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
        "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
    },
    {
        "Statement": "Lemma contains_in_set: \"contains P xs ⟶ (∃x ∈ set xs. P x)\"",
        "Description": "Define a lemma asserting that if `P` holds for an element in the list, then that element is in the set of the list."
    },
    {
        "Statement": "func :: Int -> Int",
        "Description": "Define a function named `func` which takes an `Int` and returns an `Int`."
    },
    {
        "Statement": "maybeadd mx y = mx >>= (\\x -> Just $ x+y)",
        "Description": "Use bind operator `(>>=)` to extract the value from `mx`, adds `y` to it, and wraps the result in a Just context."
    },
    {
        "Statement": "maximum :: (Ord a, Foldable t) => t a -> a",
        "Description": "Define 'maximum' as a function which finds the maximum element of a non-empty list."
    },
    {
        "Statement": "inorder (Node l v r) = inorder l ++ [v] ++ inorder r;",
        "Description": "Traverse the left subtree, add 'v', and then traverse the right subtree."
    },
    {
        "Statement": "instance ArrowApply (->) where\n  app (f, x) = f x\n\ninstance Monad m => ArrowApply (Kleisli m) where\n  app = Kleisli (\\(Kleisli f, x) -> f x)",
        "Description": "Provide instances of the 'ArrowApply' type class for the function type constructor '(->) a b' and the 'Kleisli' newtype, assuming that 'm' is an instance of the 'Monad' type class."
    },
    {
        "Statement": "Just 1 >>= (\\x -> Just x)",
        "Description": "Bind the value 1 wrapped in a Just context to the function (\\x -> Just x), resulting in Just 1."
    },
    {
        "Statement": "readUntilWithState ending = execStateT (aux ending) 0",
        "Description": "Define the `readUntilWithState` function by executing the `aux` computation within the `StateT` monad transformer, using `execStateT` to discard the result value and return the final state (the count)."
    },
    {
        "Statement": "liftIOm :: IO a -> IOMaybe a",
        "Description": "Define a function liftIOm that takes an IO computation and lifts it into the IOMaybe context, allowing for side effects while still preserving the possibility of failure."
    },
    {
        "Statement": "fst :: (a,b) -> a",
        "Description": "Return the first element of a tuple."
    },
    {
        "Statement": "Class Num a where",
        "Description": "Declare a typeclass 'Num' which represents numeric types."
    },
    {
        "Statement": "class Functor f => Applicative (f :: _\\->_ )\n\nwhere\n\n    pure :: a -> f a\n\n    (<\\*>) :: f (a -> b) -> (f a -> f b)\n\n    liftA2 :: (a -> b -> c) -> f a -> f b -> f c",
        "Description": "Define a typeclass Applicative that extends the Functor typeclass. It has three member functions: pure that takes a value a and returns a functor f a, (<\\*>) that takes a functor of functions f (a -> b) and a functor f a and returns a functor f b, and liftA2 that takes a function (a -> b -> c) and two functors f a and f b and returns a functor f c."
    },
    {
        "Statement": "instance Semigroup (Endo a) where",
        "Description": "Define a 'Semigroup' instance for the 'Endo' data type."
    },
    {
        "Statement": "liftIOm :: IO a -> IOMaybe a",
        "Description": "Define a function liftIOm that takes an IO computation and lifts it into the IOMaybe context, allowing for side effects while still preserving the possibility of failure."
    },
    {
        "Statement": "index :: Seq a -> Int -> a",
        "Description": "Declare a function index that retrieves an element at a specified index from a sequence."
    },
    {
        "Statement": "lookup p (Node _ m) = M.lookup p m",
        "Description": "For a non-leaf node, look up the path in the map and return the corresponding subtree, if it exists."
    },
    {
        "Statement": "zipWith _ [] _ = []",
        "Description": "Define the case of the zipWith function where the first list is empty, it returns an empty list."
    },
    {
        "Statement": "func x = if x == 0 then ( else f (x-1))",
        "Description": "Define `func` to return `f (x-1)` if `x` is equal to 0."
    },
    {
        "Statement": "WithProgName :: String -> IO a -> IO a",
        "Description": "Define a function 'WithProgName' which takes a string representing a new program name and an IO action, and executes the action with the specified program name."
    },
    {
        "Statement": "checkInput (x:_) = isUpper x",
        "Description": "If the input String is non-empty, check if the first character is an uppercase letter using the isUpper function, and return the result as a Bool."
    },
    {
        "Statement": "add x y = x+y",
        "Description": "Define the 'add' function such that it takes two arguments 'x' and 'y', then returns their sum."
    },
    {
        "Statement": "(==) (C n) (C m) = n == m",
        "Description": "Define the equality operator '==' for comparing two temperatures in Celsius. It returns true if their values are equal."
    },
    {
        "Statement": "input ‹- getLine",
        "Description": "Read a line of input from the user and bind it to the variable input."
    },
    {
        "Statement": "lemma map_contains: \"contains P (map f xs) ⟷ contains (λx. P (f x)) xs\"",
        "Description": "Define a lemma asserting that `P` holds for an element in the mapped list if and only if `P` holds for the original list."
    },
    {
        "Statement": "Nothing >>= _ = Nothing",
        "Description": "If the input to the bind operation is Nothing, return Nothing."
    },
    {
        "Statement": "show :: a -> String",
        "Description": "Define a function 'show' within the 'Show' typeclass which takes a value of type 'a' and returns a string representation."
    },
    {
        "Statement": "con \"trim\" (dropWhile isSpace . reverse . dropWhile isSpace . reverse :: String -> String),",
        "Description": "Include the 'trim' function signature."
    },
    {
        "Statement": "\"shows 'sorted (inorder l @ [v] @ inorder r)'\"",
        "Description": "Show that the inorder traversal of l, followed by v, followed by the inorder traversal of r, is sorted."
    },
    {
        "Statement": "lemma contains_take: \"contains P (take n xs) ⟶ contains P xs\"",
        "Description": "Define a lemma asserting that if `P` holds for an element in the taken list, then `P` holds for that element in the original list."
    },
    {
        "Statement": "evens = map (*2) nat\nodds = filter (\\x -> mod x 2 == 0) nat",
        "Description": "Define an infinite list named evens where each element is twice the corresponding element in the list nat. Also, define an infinite list named odds where each element is an even number from the list nat using filtering."
    },
    {
        "Statement": "Nothing -> return Nothing",
        "Description": "If maybe_val is Nothing, return a failed IOMaybe computation by returning Nothing."
    },
    {
        "Statement": "newtype Sum a = Sum { getSum :: a }",
        "Description": "Define a new data type called 'Sum' with a single constructor 'Sum' that wraps a value of type 'a'. The 'getSum' function extracts the value of type 'a' from the 'Sum' constructor."
    },
    {
        "Statement": "descSort = (\\x -> reverse (sort x))",
        "Description": "Define 'descSort' as a lambda function that reverses the sorted input list 'x'."
    },
    {
        "Statement": "quicksort :: Ord a => [a] -> [a]",
        "Description": "Define a function quicksort that takes a list of elements and returns a new list with the same elements, sorted in ascending order."
    },
    {
        "Statement": "name <args> = ... name <args'> ...",
        "Description": "Define a recursive function named 'name' that takes arguments '<args>' and recurses on itself with arguments '<args>'."
    },
    {
        "Statement": "someAction = do ... ... ... return $! f x",
        "Description": "Perform some actions, and then evaluate the result of f x strictly before returning it."
    },
    {
        "Statement": "class Arrow a => ArrowLoop (a :: _->_ -> *)\n  where\n    loop :: a (b, d) (c, d) -> a b c",
        "Description": "Define a type class 'ArrowLoop' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowLoop' class specifies a single method 'loop' for creating feedback loops."
    },
    {
        "Statement": "length Nil = 0",
        "Description": "If the input list is Nil, return 0."
    },
    {
        "Statement": "greet :: IO ()",
        "Description": "Declares a function 'greet' that performs IO actions."
    },
    {
        "Statement": "type SomeData = Either Int String,[Left 1, Right \"Hello\"] :: [SomeData]",
        "Description": "Define a type synonym 'SomeData' for 'Either Int String', and creates a list containing a 'Left' value with 1 and a 'Right' value with 'Hello'."
    },
    {
        "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
        "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'First a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
    },
    {
        "Statement": "isNothing :: Maybe a -> Bool",
        "Description": "Define a function 'isNothing' which takes a 'Maybe' value and returns 'True' if it is a 'Nothing' value, otherwise returns 'False'."
    },
    {
        "Statement": "\"(Vrv e setT r. rv > v)\"",
        "Description": "Assume that for every `rv` in the set of `r`, `rv` is greater than `v`."
    },
    {
        "Statement": "import Data.List (foldl')\n\ndrop' :: Int -> [a] -> [a]",
        "Description": "Define a function 'drop'' that takes an integer 'n' and a list of elements of any type 'a', and returns a list containing all elements of the input list except the first 'n' elements. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
    },
    {
        "Statement": "import Data.List (inits)\n\nprefixes :: [a] -> [[a]]",
        "Description": "Define a function 'prefixes' that takes a list of elements of any type 'a' and returns a list of all prefixes (initial segments) of the input list, including the empty list and the input list itself. Import the 'inits' function from the 'Data.List' module."
    },
    {
        "Statement": "f $! x = x 'seq' f x",
        "Description": "Define the ($!) operator to evaluate the value x strictly using seq before applying the function f to it."
    },
    {
        "Statement": "deleteFirstsBy _ xs [] = xs",
        "Description": "Define the case of the deleteFirstsBy function where the second list is empty, it returns the first list."
    },
    {
        "Statement": "apply (induct t)",
        "Description": "Begin the proof by induction over tree `t`."
    },
    {
        "Statement": "data Either a b = Left a | Right b",
        "Description": "Define a data type 'Either' which represents a value of one of two possible types, 'a' or 'b'."
    },
    {
        "Statement": "instance Applicative [] where\n    pure x = [x]\n    fs <*> xs = [f x | f <- fs, x <- xs]\n    _ *> ys = ys\n    xs <* _ = xs",
        "Description": "Provide an instance of the 'Applicative' type class for the list data type '[]'. This instance allows for applying and combining list computations."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Read a line of input from the user and bind it to input."
    },
    {
        "Statement": "where f = reverse . dropWhile isSpace",
        "Description": "Define the function `f` to remove trailing whitespace."
    },
    {
        "Statement": "Lemma sorted node:",
        "Description": "Define a lemma named sorted_node."
    },
    {
        "Statement": "ghci> :i Exception",
        "Description": "View the information about the Exception class in GHCi."
    },
    {
        "Statement": "failing :: IO ()",
        "Description": "Define a function failing of type IO () that throws an exception of type Error."
    },
    {
        "Statement": "delete' :: Eq a => a -> [a] -> [a]",
        "Description": "Define a function delete' that takes an element x and a list xs, and returns a new list with the first occurrence of x removed from xs."
    },
    {
        "Statement": "left = take (length xs `div` 2) xs",
        "Description": "Define 'left' as the first half of the list."
    },
    {
        "Statement": "inorder (Node l v f) = (inorder l) @ [v] @ (inorder r)",
        "Description": "Otherwise, return the list obtained by concatenating the inorder traversal of the left branch, `v`, and the inorder traversal of the right branch."
    },
    {
        "Statement": "have sorted_right: \"sortedT r\" using 2 sorted node by blast",
        "Description": "declare that 'r' is sorted."
    },
    {
        "Statement": "where",
        "Description": "Begin definition of the sortedT abbreviation."
    },
    {
        "Statement": "append :: List a -> List a -> List a",
        "Description": "Define a function named append which takes two Lists of elements of type a and returns their concatenation as a List of the same type."
    },
    {
        "Statement": "negate :: a -> a",
        "Description": "Define the negation operation 'negate' within the 'Num' typeclass which takes a value of type 'a' and returns a value of type 'a'."
    },
    {
        "Statement": "map :: (a -> b) -> Seq a -> Seq b",
        "Description": "Declare a function map that applies a function to each element of a sequence."
    },
    {
        "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
        "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
    },
    {
        "Statement": "import Data.Char (isUpper)\n\ncapitalize :: String -> String",
        "Description": "Define a function 'capitalize' that takes a string and returns a new string with the first character capitalized (if it is a letter) and the remaining characters unchanged. Import the 'isUpper' function from the 'Data.Char' module."
    },
    {
        "Statement": "evalStateT :: Monad m => StateT s m a -> s -> m a",
        "Description": "Declare a function evalStateT that takes a StateT computation and an initial state, and returns a monadic computation that produces the final result, discarding the final state."
    },
    {
        "Statement": "readChan :: Chan a -> IO a",
        "Description": "Read a value of type a from the given channel, blocking until there is a sender."
    },
    {
        "Statement": "instance MonadTrans (ExceptT e) where\n    lift = ExceptT . liftM Right",
        "Description": "Provide an instance of the 'MonadTrans' type class for the 'ExceptT' monad transformer. This instance allows for lifting computations into the 'ExceptT' monad transformer."
    },
    {
        "Statement": "where types = (x :: Maybe Int, y :: Maybe Int)",
        "Description": "Specify the types of 'x' and 'y' as 'Maybe' integers for the 'prop' function."
    },
    {
        "Statement": "product' :: Num a => [a] -> a",
        "Description": "Define a function product' that takes a list of numbers and returns the product of all the numbers in the list."
    },
    {
        "Statement": "then returnIOM input",
        "Description": "If the condition is satisfied, return the input wrapped in a Just constructor using returnIOM."
    },
    {
        "Statement": "sum [] = 0",
        "Description": "Base case: If the list is empty, the sum is 0."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Read a line of input from the user and bind it to the variable input."
    },
    {
        "Statement": "apply auto",
        "Description": "Use the `auto` tactic to solve the subgoal."
    },
    {
        "Statement": "return x = Just x",
        "Description": "Define the return function for the Maybe monad, which wraps a value in Just."
    },
    {
        "Statement": "input <- getLine",
        "Description": "Get a line of input from the user using the getLine function from the IO monad."
    },
    {
        "Statement": "where aux ending count = do",
        "Description": "Begin the definition of the `aux` function using the do notation for monadic computations. The `aux` function takes the `ending` string and the current `count` as arguments."
    },
    {
        "Statement": "intersperse :: a -> [a] -> [a]",
        "Description": "Define 'intersperse' as a function which takes an element and a list, and puts the element between each pair of elements in the list."
    },
    {
        "Statement": "unzip [] = ([], [])",
        "Description": "If the list is empty, return a pair of empty lists."
    },
    {
        "Statement": "    | otherwise = x : deleteBy eq y xs",
        "Description": "Define the condition for the recursive case of the deleteBy function. If the predicate 'eq' is not satisfied by the current element 'x' and 'y', it keeps 'x' and recursively processes the rest of the list."
    },
    {
        "Statement": "rotateList n xs = take (length xs) (drop n (cycle xs))",
        "Description": "Rotate the list to the left by `n` positions using `cycle`, `drop`, and `take` functions."
    },
    {
        "Statement": "take' :: Int -> [a] -> [a]",
        "Description": "Define a function take' that takes an integer n and a list xs, and returns the first n elements of xs."
    },
    {
        "Statement": "rev::\n[a] -> [a]",
        "Description": "Define 'rev' as a function which takes a list of 'a' and returns a list of 'a'."
    },
    {
        "Statement": "removeDuplicates :: Eq a => [a] -> [a]",
        "Description": "Define a function 'removeDuplicates' that takes a list of elements of type 'a' (which must be an instance of the 'Eq' typeclass) and returns a list with duplicates removed."
    },
    {
        "Statement": "treeToSet :: Ord a => Tree a -> Set a",
        "Description": "Define a function 'treeToSet' that converts a binary tree of type 'Tree a' into a set ('Set a'), assuming the type 'a' is an instance of the 'Ord' class."
    },
    {
        "Statement": "(==) (F f) (C c) = (1.8c + 32) == f",
        "Description": "Define the equality operator '==' for comparing a temperature in Fahrenheit with a temperature in Celsius. It returns true if the Celsius temperature, when converted to Fahrenheit, is equal to the given Fahrenheit temperature."
    },
    {
        "Statement": "instance Monoid w => Monad ((,) w) where\n    return x = (mempty, x)\n    (u, a) >>= k = let (v, b) = k a in (u `mappend` v, b)\n    (>>) = (*>)",
        "Description": "Provide an instance of the 'Monad' type class for the tuple type constructor '(,) w', assuming that 'w' is an instance of the 'Monoid' type class. This instance allows for sequencing and combining computations."
    },
    {
        "Statement": "checkInput [] = False",
        "Description": "If the input String is empty, return False."
    },
    {
        "Statement": "map (\\(x,y) -> x+y) [(1,2), (2,3), (3,4)]",
        "Description": "Applly the anonymous function ((x,y) -> x+y) to each tuple in the list [(1,2), (2,3), (3,4)] using 'map', resulting in [3,5,7]."
    },
    {
        "Statement": "filter :: (a -> Bool) -> Seq a -> Seq a",
        "Description": "Declare a function filter that filters elements from a sequence based on a predicate."
    },
    {
        "Statement": "length :: [a] -> Int",
        "Description": "Return the number of elements in a list."
    },
    {
        "Statement": "where f' x y = f (x, snd y )",
        "Description": "Define a helper function f' that takes x and y, and applies the original function f to (x, snd y), where snd y is the second component of y."
    },
    {
        "Statement": "drop :: Int -> Seq a -> Seq a",
        "Description": "Declare a function drop that removes the specified number of elements from the beginning of a sequence."
    },
    {
        "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
        "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
    },
    {
        "Statement": "if z then x else y",
        "Description": "Conditional Statement that evaluates 'z'. If 'z' is true, evaluates 'x'; otherwise, evaluates 'y'."
    },
    {
        "Statement": "sorry",
        "Description": "Indicate the proof is skipped for now."
    },
    {
        "Statement": "class Arrow a => ArrowChoice (a :: _->_ -> *)\n  where\n    lift :: a b c -> a (Either b d) (Either c d)\n    right :: a b c -> a (Either d b) (Either d c)\n    (+++) :: a b c -> a b' c' -> a (Either b b') (Either c c')\n    (|||) :: a b d -> a b d -> a (Either b c) d",
        "Description": "Define a type class 'ArrowChoice' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowChoice' class specifies methods for working with sum types (e.g., 'Either') and choice operations."
    },
    {
        "Statement": "prop xs = not (null xs) ==> (length xs) -1)",
        "Description": "Define a property named prop that states if xs is not null, then the length of xs minus one is equal to itself."
    },
    {
        "Statement": "    | p x = dropWhile p xs",
        "Description": "Define the condition for the recursive case of the dropWhile function. If the predicate 'p' holds true for the current element 'x', it recursively processes the rest of the list."
    },
    {
        "Statement": "checkFirstChar (x:_) = isUpper x",
        "Description": "If the input string is non-empty, check if the first character is uppercase and return the result."
    },
    {
        "Statement": "dropWhileEnd :: (a -> Bool) -> [a] -> [a]",
        "Description": "Define a function dropWhileEnd that takes a predicate p and a list xs, and returns the list xs after removing the longest suffix that satisfies p."
    },
    {
        "Statement": "data ExitCode = ExitSuccess | ExitFailure Int",
        "Description": "Define a custom data type 'ExitCode' which represents the status of program termination, either success or failure with an integer code."
    },
    {
        "Statement": "fac n",
        "Description": "Define `fac` with parameter `n`."
    },
    {
        "Statement": "Class Show a where",
        "Description": "Declare a typeclass 'Show' which represents types that can be converted to strings."
    },
    {
        "Statement": "con \"realPart\" (realPart :: Complex Float -› Float),",
        "Description": "Include the 'realPart' function signature in 'complexSig'."
    },
    {
        "Statement": "returnIOM :: a -> IOMaybe a",
        "Description": "Define a function returnIOM that takes a value of type a and returns a successful IOMaybe computation with that value."
    },
    {
        "Statement": "reverse Nil = Nil",
        "Description": "If the input list is Nil, return Nil."
    },
    {
        "Statement": "insert :: a -> Set a -> Set a",
        "Description": "Declare a function insert that adds an element to a set."
    },
    {
        "Statement": "evens :: [Int] -> [Int]",
        "Description": "Define a function 'evens' that takes a list of integers and returns a list containing only the even integers."
    },
    {
        "Statement": "int y = func2 (arg);",
        "Description": "Define a variable 'y' of type integer which is assigned the result of calling function 'func2' with argument 'arg'."
    },
    {
        "Statement": "newtype NonEmpty a = NonEmpty { getNonEmpty :: (a, [a]) }",
        "Description": "Define a new data type called 'NonEmpty' with a single constructor 'NonEmpty' that wraps a tuple containing a value of type 'a' and a list of type '[a]'. The 'getNonEmpty' function extracts the tuple from the 'NonEmpty' constructor."
    },
    {
        "Statement": "instance Monad IO",
        "Description": "Define a Monad instance for IO actions."
    },
    {
        "Statement": "ones = 1 : ones",
        "Description": "Define an infinite list named ones where each element is 1 followed by itself, creating an infinite cycle."
    },
    {
        "Statement": "mono Typeobserve (Proxy :: Proxy (Complex Float)),",
        "Description": "Include the 'Complex Float' type proxy in 'complexSig'."
    },
    {
        "Statement": "module SortingAlgorithms",
        "Description": "Define a module named SortingAlgorithms."
    },
    {
        "Statement": "(Just x) >>= f = f x",
        "Description": "If the input to the bind operation is Just x, apply the function f to x and return the result."
    },
    {
        "Statement": "con\n(revAcc :: [A] -> [A]),",
        "Description": "Define 'revAcc' as a function which takes a list of 'A' and returns a list of 'A'."
    },
    {
        "Statement": "\"sortedT t At = (Node l v r) → sortedT 1 A sortedT r\"",
        "Description": "If the tree `t` is sorted, then for every `Node l v r`, `l` and `r` are sorted."
    },
    {
        "Statement": "instance Monoid w => WriterMonad w ((,) w) where\n    writer = id\n    runWriter = id\n    tell w = ((), w)\n    listen m = (m, snd m)\n    pass (m, f) = (fst m, f $ snd m)",
        "Description": "Provide an instance of the 'WriterMonad' type class for the tuple type constructor '(,) w', assuming that 'w' is an instance of the 'Monoid' type class. This instance allows for working with computations that produce a log along with a value."
    },
    {
        "Statement": "import Test.QuickCheck-Arbitrary",
        "Description": "Import the Test.QuickCheck-Arbitrary module."
    },
    {
        "Statement": "(==) (F n) (F m) = n == m",
        "Description": "Define the equality operator '==' for comparing two temperatures in Fahrenheit. It returns true if their values are equal."
    },
    {
        "Statement": "fac :: Int -> Int",
        "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
    },
    {
        "Statement": "| otherwise = n * fac (n-1)",
        "Description": "Otherwise, return `n * fac (n-1)`."
    },
    {
        "Statement": "f = either (\\l -> \"Number\") (\\r -> r)",
        "Description": "Define a function 'f' which uses the 'either' function to map 'Left' values to 'Number' and 'Right' values to themselves."
    },
    {
        "Statement": "instance Monoid (NonEmpty a) where",
        "Description": "Define a 'Monoid' instance for the 'NonEmpty' data type."
    },
    {
        "Statement": "filterString :: String -> String",
        "Description": "Define a function filterString that takes a String and removes non-alphabetic characters."
    },
    {
        "Statement": "packConsecutive = group . sort",
        "Description": "The implementation of 'packConsecutive' uses function composition: first, sort the input list using 'sort', then group consecutive duplicate elements into sublists using 'group'."
    },
    {
        "Statement": "otherwise = n * fac (n-1)",
        "Description": "Otherwise, return `n * fac (n-1)`."
    },
    {
        "Statement": "takeWhile :: (a -> Bool) -> [a] -> [a]",
        "Description": "Define 'takeWhile' as a function which takes elements from a list while the predicate holds."
    },
    {
        "Statement": "maybe_val <- iom",
        "Description": "Bind the result of evaluating iom to maybe_val."
    },
    {
        "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
        "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
    },
    {
        "Statement": "import Data.List (isInfixOf)\n\ncontains :: Eq a => [a] -> [a] -> Bool",
        "Description": "Define a function 'contains' that takes two lists of elements of any type 'a' that implements the 'Eq' typeclass, and returns 'True' if the first list is a substring (infix) of the second list, and 'False' otherwise. Import the 'isInfixOf' function from the 'Data.List' module."
    },
    {
        "Statement": "apply (induction t2)",
        "Description": "Begin the proof by induction over tree t2."
    },
    {
        "Statement": "foldr1 :: (a -> a -> a) -> Seq a -> a",
        "Description": "Declare a function foldr1 that folds a non-empty sequence from the right with a binary function."
    },
    {
        "Statement": "module main where",
        "Description": "Start of the main module."
    },
    {
        "Statement": "    | x == y = isPrefixOf xs ys",
        "Description": "Define the condition for the recursive case of the isPrefixOf function. If the current elements 'x' and 'y' are equal, it recursively checks the remaining lists."
    },
    {
        "Statement": "    | p x = (x:ys, zs)",
        "Description": "Define the condition for the recursive case of the partition function. If the predicate 'p' is satisfied by the current element 'x', it is added to the first component of the resulting pair."
    },
    {
        "Statement": "import Data.List (sort)",
        "Description": "Import the 'sort' function from the Data.List module, which sorts a list in ascending order."
    },
    {
        "Statement": "scanl :: (a -> b -> a) -> a -> Seq b -> Seq a",
        "Description": "Declare a function scanl that scans a sequence from the left with a binary function."
    },
    {
        "Statement": "splitAt n xs = (take n xs, drop n xs)",
        "Description": "The implementation of 'splitAt' uses the 'take' function to get the first 'n' elements from the input list 'xs', and the 'drop' function to get the remaining elements after dropping the first 'n' elements."
    },
    {
        "Statement": "loop f b = let (c, d) = f(b, d) in c",
        "Description": "Define the loop function for the ArrowApply instance of (->) that takes a function f and a value b, applies f to (b, d) where d is some undefined value, and returns the first component of the result."
    },
    {
        "Statement": "sum :: Num p => [p] -> p",
        "Description": "Define a function 'sum' which takes a list of values of type 'p' belonging to the 'Num' typeclass and returns a single value of type 'p'."
    },
    {
        "Statement": "map' :: (a -> b) -> [a] -> [b]",
        "Description": "Define a function map' that takes a function f and a list xs, and returns a new list containing the result of applying f to each element of xs."
    },
    {
        "Statement": "toGraph :: [Node a] -> Graph",
        "Description": "Define a function 'toGraph' that takes a list of nodes '[Node a]' and converts it into a 'Graph' data structure."
    },
    {
        "Statement": "maximum = foldl1 max",
        "Description": "Define 'maximum' as a function which finds the maximum element of a non-empty list using the 'max' function."
    },
    {
        "Statement": "cycle xs = xs ++ cycle xs",
        "Description": "Otherwise, concatenate the list with itself infinitely."
    },
    {
        "Statement": "liftIOm io :: io >>= retrunIOM",
        "Description": "Define liftIOm io as io >>= returnIOM."
    },
    {
        "Statement": "map [] = []",
        "Description": "If the list is empty, return an empty list."
    },
    {
        "Statement": "putMVar :: MVar a -> a -> IO ()",
        "Description": "Put a value of type a into the given MVar, blocking until the MVar is empty."
    },
    {
        "Statement": "hn = n",
        "Description": "Assign `hn` the value of `n`."
    },
    {
        "Statement": "isAll e = foldr (\\x acc -> e == x && acc) True",
        "Description": "Define 'isAll' as a fold operation that checks if all elements in the list are equal to 'e'."
    },
    {
        "Statement": "]",
        "Description": "End the 'complexSig' list definition."
    },
    {
        "Statement": "startsWith :: Eq a => [a] -> [a] -> Bool",
        "Description": "Define a function 'startsWith' that takes two lists of elements of type 'a' (which must be an instance of the 'Eq' typeclass) and returns 'True' if the first list is a prefix of the second list, and 'False' otherwise."
    },
    {
        "Statement": "| otherwise = func (x-y) (y*2) (z+1)",
        "Description": "Otherwise, recursively call `func` with `(x-y)`, `(y*2)`, and `(z+1)`."
    },
    {
        "Statement": "con \":==\" ((==) :: Int -> Int -> Bool),",
        "Description": "Include the ':==' operator signature."
    },
    {
        "Statement": "    | p x = x : takeWhile p xs",
        "Description": "Define the condition for the recursive case of the takeWhile function. If the predicate 'p' holds true for the current element 'x', it adds 'x' to the result."
    },
    {
        "Statement": "instance MonadReader r m => MonadReader r (StateT s m) where\n    ask = lift ask\n    local f (StateT g) = StateT $ \\s -> local f (g s)",
        "Description": "Provide an instance of the 'MonadReader' type class for the 'StateT' monad transformer, assuming that 'm' is an instance of the 'MonadReader' type class. This instance allows for reading the environment within the 'StateT' monad transformer."
    },
    {
        "Statement": "and = foldr (&&) True",
        "Description": "Define 'and' as a fold operation using the '&&' operator and starting with an initial accumulator of 'True'."
    },
    {
        "Statement": "mempty = Last Nothing",
        "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Last a' as a 'Last' value wrapping 'Nothing'."
    },
    {
        "Statement": "(<>) = coerce ((||) :: a -> a -> a)",
        "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Any a' by converting the '(||)' function for type 'a' to the appropriate type using 'coerce'."
    },
    {
        "Statement": "instance Monad []",
        "Description": "Create an instance of the Monad typeclass for the list type constructor [], which represents computations that can return multiple values."
    },
    {
        "Statement": "module SortingAlgorithms",
        "Description": "Define a module named SortingAlgorithms."
    },
    {
        "Statement": "import Data.Set (Set, empty, insert, union)",
        "Description": "Import the 'Set' data type and related functions from the 'Data.Set' module, which provides a set data structure."
    },
    {
        "Statement": "background [\npredicate \"<\" ((<) :: Int -> Int -> Bool),",
        "Description": "Declare the signature for the '<' function."
    },
    {
        "Statement": "instance MonadTrans (StateT s) where\n    lift m = StateT $ \\s -> do\n        a <- m\n        return (a, s)",
        "Description": "Provide an instance of the 'MonadTrans' type class for the 'StateT' monad transformer. This instance allows for lifting computations into the 'StateT' monad transformer."
    },
    {
        "Statement": "sum (x: xs) = x + sum xs",
        "Description": "Sum the first element x with the sum of the remaining elements xs recursively."
    },
    {
        "Statement": "map (\\x -> x+1) [1,2,3,4,5]",
        "Description": "Applly the anonymous function (\\x -> x+1) to each element of the list [1,2,3,4,5] using 'map', resulting in [2,3,4,5,6]."
    },
    {
        "Statement": "loop (Kleisli f) = Kleisli (liftM fst . mfix . f')",
        "Description": "Define the loop function for the Arrowloop instance of Kleisli m, which applies the mfix function to a modified version of the original function f, and then lifts the first component of the result using liftM fst."
    },
    {
        "Statement": "map f (x:xs) = f x : map f xs",
        "Description": "Otherwise, apply function `f` to the first element `x` and recursively apply `map` to the rest of the list."
    },
    {
        "Statement": "mergeSort :: Ord a => [a] -> [a]",
        "Description": "Define a function 'mergeSort' that takes a list of elements of type 'a' (which must be an instance of the 'Ord' typeclass) and returns a sorted list."
    },
    {
        "Statement": "  (>>) :: m a -> m b -> m b",
        "Description": "Define the sequencing operator (>>), which discards the result of the first action and executes the second action."
    },
    {
        "Statement": "isEven n",
        "Description": "Define `isEven` with parameter `n`."
    },
    {
        "Statement": "checkInput :: String -> Bool",
        "Description": "Define a function checkInput that takes a String and returns a Bool."
    },
    {
        "Statement": "where",
        "Description": "Begin the definition of helper functions for 'frequencies'."
    },
    {
        "Statement": "revAcc :: [a] -> [a]",
        "Description": "Define 'revAcc' as a function which takes a list of 'a' and returns a list of 'a'."
    },
    {
        "Statement": "die :: String -> IO a",
        "Description": "Define a function 'die' which takes a string argument and performs an IO action that terminates the program with a failure status and prints the specified string as an error message."
    },
    {
        "Statement": "instance Num a => Semigroup (Sum a) where\n  (<>) = coerce ((+) :: a -> a -> a)\n  stimes n (Sum a) = Sum (fromIntegral n * a)",
        "Description": "Provide an instance of Semigroup for the Sum data type, where the (<>) operation is defined as the addition of the wrapped values, and stimes is defined as scalar multiplication of the wrapped value by an integer."
    },
    {
        "Statement": "then show ?thesis using True sets value sortedT \"2.IH\" (1) sorted left sorted right tv disjunct by auto",
        "Description": "then show the thesis using the given data and the assumed statement."
    },
    {
        "Statement": "fac n",
        "Description": "Define `fac` with parameter `n`."
    },
    {
        "Statement": "sorted [] = True",
        "Description": "If the list is empty, return True."
    },
    {
        "Statement": "getProgname :: IO String",
        "Description": "Define a function 'getProgname' which returns the program name as an IO action."
    },
    {
        "Statement": "inorder :: forall a. Tree a -> [a];",
        "Description": "Define a function 'inorder' which takes a 'Tree a' and returns a list of 'a'."
    },
    {
        "Statement": "(>>>=) = bindIOM",
        "Description": "Define the fish operator (>>>=) as a synonym for the bindIOM function, which is a common convention in Haskell."
    },
    {
        "Statement": "import Data.List (sort, group)\n\npackConsecutive :: Ord a => [a] -> [[a]]",
        "Description": "Define a function 'packConsecutive' that takes a list of elements of any type 'a' that implements the 'Ord' typeclass, and returns a list of lists, where each sublist contains consecutive duplicate elements from the input list. Import the 'sort' and 'group' functions from the 'Data.List' module."
    },
    {
        "Statement": "mempty = Endo id",
        "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Endo a' as an 'Endo' value wrapping the 'id' function."
    },
    {
        "Statement": "map :: (a -> b) -> [a] -> [b]",
        "Description": "Define a function 'map' which takes a function from 'a' to 'b' and a list of 'a's, returning a list of 'b's."
    },
    {
        "Statement": "]",
        "Description": "End of the list."
    },
    {
        "Statement": "let (x,y) = (1,2) in x",
        "Description": "Bind the tuple (1,2) to variables x and y, then returns the value of x, which is 1."
    },
    {
        "Statement": "import Data.Tree.Zipper",
        "Description": "Import the 'Data.Tree.Zipper' module, which provides a zipper data structure for navigating and modifying trees."
    },
    {
        "Statement": "else readUntil ending",
        "Description": "If the input is not the ending string, recursively call readUntil with the ending string."
    },
    {
        "Statement": "| otherwise = []",
        "Description": "Otherwise, stop taking elements."
    },
    {
        "Statement": "bindIOM :: IOMaybe a -> (a -> IOMaybe b) -> IOMaybe b",
        "Description": "Define a function bindIOM that takes an IOMaybe computation and a function that takes a value of type a and returns an IOMaybe computation of type b, and returns a new IOMaybe computation of type b that combines the two computations."
    },
    {
        "Statement": "sum (x:xs) = x + sum xs",
        "Description": "Recursive case: If the list is not empty, sum the head of the list 'x' with the sum of the rest of the list 'xs'."
    },
    {
        "Statement": "lemma tree_subset:",
        "Description": "Define a lemma named tree_subset."
    },
    {
        "Statement": "splice xs [] = xs",
        "Description": "If the second list is empty, return the first list xs as the result of splicing."
    },
    {
        "Statement": "foldr' :: (a -> b -> b) -> b -> Seq a -> b",
        "Description": "Declare a function foldr' that folds a sequence strictly from the right with a binary function."
    }
]