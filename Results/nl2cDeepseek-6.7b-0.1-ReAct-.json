[
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDeclare a module named \"Anagram\" exporting the function \"anagramsFor\".\nOutput:\n",
        "base_model": "anagramsFor :: String -> [String] -> [String]\nanagramsFor \"listen\" [\"enlists\", \"google\", \"inlets\", \"banana\"]\n[\"inlets\"]\nanagramsFor \"massage\" [\"stream\", \"massage\", \"just\"]\n[\"stream\", \"massage\"]\nanagramsFor \"massage\" [\"stream\", \"massage\", \"just\", \"massage\"]\n[\"stream\", \"massage\", \"massage\"]\nanagramsFor \"massage\" [\"stream\", \"massage\", \"just\", \"massage\", \"stream\"]\n[\"stream\", \"massage\", \"massage\", \"stream\"]\nanagramsFor \"massage\" [\"stream\", \"massage\", \"just\", \"massage\", \"stream\", \"stream\"]\n[\"stream\", \"massage\", \"massage\", \"stream\", \"stream\"]\nanagrams"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nImport the \"Data.List\" module for list manipulation functions. Import the \"Data.Char\" module for character manipulation functions.\nOutput:\n",
        "base_model": "\n1. Define a function \"myConcat\" that takes a list of strings as input and concatenates them into a single string.\n\n2. Define a function \"myIntersect\" that takes two lists as input and returns a list containing the elements that appear in both lists.\n\n3. Define a function \"myUnion\" that takes two lists as input and returns a list containing the elements that appear in either list.\n\n4. Define a function \"myDifference\" that takes two lists as input and returns a list containing the elements that appear in the first list but not the second.\n\n5. Define a function \"myInsert\" that takes an element and a list as input and inserts the element into the list at the first occurrence of the element in the list.\n\n6. Define a function \"mySort\" that takes a list of integers as input and returns a sorted list"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDeclare a function named \"lower\" converting all characters of a String to lowercase. Define the \"lower\" function using \"map\" and \"toLower\" for lowercase conversion.\nOutput:\n",
        "base_model": "lower \"HELLO\"\n\"hello\"\nlower \"Haskell\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower \"HASKELL\"\n\"haskell\"\nlower"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDeclare a function named \"normalize\" to convert a String to lowercase and sort its characters. Define the \"normalize\" function using function composition with \"sort\" and \"lower\".\nOutput:\n",
        "base_model": "normalize \"Hello\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehllo\"\nnormalize \"hELLO\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehllo\"\nnormalize \"HELLO\"\n\"ehll"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDeclare a function named \"anagram\" to check if two Strings are anagrams. Define the \"anagram\" function to compare lowercase versions and sorted versions of input Strings.\nOutput:\n",
        "base_model": "\nanagram \"elbow\" \"below\"\nTrue\nanagram \"below\" \"elbow\"\nTrue\nanagram \"Tesla\" \"Sale\"\nFalse\nanagram \"below\" \"elbows\"\nFalse\nanagram \"Borrow\" \"Borrow\"\nTrue\nanagram \"Borrow\" \"Borrowed\"\nFalse\nanagram \"Borrow\" \"Borrowed\"\nFalse\nanagram \"Borrow\" \"Borrowed\"\nFalse\nanagram \"Borrow\" \"Borrowed\"\nFalse\nanagram \"Borrow\" \"Borrowed\"\nFalse\nanagram \"Borrow\" \"Borrowed\"\nFalse\nanagram \"Borrow\" \"Borrowed\"\nFalse\nanagram \"Borrow\" \"Borrowed\"\nFalse\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDeclare a function named \"anagramsFor\" to find anagrams of a String in a list of Strings. Define the \"anagramsFor\" function using \"filter\" to select anagrams from the input list based on the \"anagram\" function.\nOutput:\n",
        "base_model": "\n> anagramsFor :: String -> [String] -> [String]\n> anagramsFor word list = filter (anagram word) list\n\n> anagram :: String -> String -> Bool\n> anagram word1 word2 = sort word1 == sort word2\n\n> sort :: String -> String\n> sort [] = []\n> sort (x:xs) = sort [a | a <- xs, a <= x] ++ [x] ++ sort [b | b <- xs, b > x]\n\n> main :: IO ()\n> main = do\n>   print (anagramsFor \"listen\" [\"enlists\", \"google\", \"inlets\", \"banana\""
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDeclare a module named Clock and export three functions: addDelta, fromHourMin, and toString.\nOutput:\n",
        "base_model": "\n> module Clock where\n>\n> import Data.Time.Clock\n> import Data.Time.Calendar\n> import Data.Time.Format\n>\n> addDelta :: TimeOfDay -> TimeOfDay -> TimeOfDay\n> addDelta t1 t2 =\n>   let (h1, m1, s1) = toClockTime t1\n>       (h2, m2, s2) = toClockTime t2\n>       (h3, m3, s3) = toClockTime (addToClock (h1, m1, s1) (h2, m2, s2))\n>   in fromClockTime (h3, m3, s3)\n>\n> fromHourMin :: Int -> Int -> TimeOfDay\n> fromHourMin h m =\n>"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nImport the printf function from the Text.Printf module for string formatting.\nOutput:\n",
        "base_model": "\nThe function should take a list of integers as input and return a string that contains the sum of all even numbers in the list.\n\nThe function should return \"0\" if the list is empty.\n\nThe function should return \"0\" if the list contains only odd numbers.\n\nThe function should return \"0\" if the list contains only negative numbers.\n\nThe function should return \"0\" if the list contains only positive numbers.\n\nThe function should return \"0\" if the list contains only numbers that are multiples of 3.\n\nThe function should return \"0\" if the list contains only numbers that are multiples of 5.\n\nThe function should return \"0\" if the list contains only numbers that are multiples of 7.\n\nThe function should return \"0\" if the list contains only numbers that are multiples of 11.\n\nThe function should return \"0\" if the list contains only numbers"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine a data type named Clock with a single field dayMins of type Int, indicating the number of minutes since midnight. Make sure to automatically generate equality comparisons for Clock instances.\nOutput:\n",
        "base_model": "data Clock = Clock { dayMins :: Int }\ninstance Eq Clock where\n  (==) = undefined\n\nDefine a function named addClock that takes two arguments: a Clock and an Int, and returns a Clock. The returned Clock should be the same as the input Clock, but with the number of minutes since midnight increased by the input Int.\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine a function that takes hours and minutes as arguments and returns a Clock object representing that time. Calculate the total minutes since midnight and ensure the time wraps around if it exceeds a day.\nOutput:\n",
        "base_model": "\n> data Clock = Clock { getHours :: Int, getMinutes :: Int }\n>     deriving (Show, Eq)\n>\n> clock :: Int -> Int -> Clock\n> clock = undefined\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine a function that takes a Clock object and returns a formatted string representing the time in the format \"HH:MM\". Extract the dayMins field and format it using printf, padding the hour and minute components with zeros if necessary.\nOutput:\n",
        "base_model": "\n```haskell\nformatTime :: Clock -> String\nformatTime clock = printf \"%02d:%02d\" hour minute\n  where\n    dayMins = clockDayMins clock\n    hour = dayMins `div` 60\n    minute = dayMins `mod` 60\n```\n\nDefine a function that takes a Clock object and returns a new Clock object with the time advanced by one minute. Extract the dayMins field and increment it by 1.\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine a function that takes hours, minutes, and a Clock object as arguments. Return a new Clock object representing the time after adding the specified delta. Add the delta to the current number of minutes since midnight, handle wrapping around if necessary, and construct a new Clock object with the updated time.\nOutput:\n",
        "base_model": "\n> class Clock where\n>   newtype Clock = Clock { getHour :: Int }\n>   newtype Minutes = Minutes { getMinutes :: Int }\n>   newtype Hours = Hours { getHours :: Int }\n>   newtype Delta = Delta { getDelta :: Int }\n>   addDelta :: Clock -> Minutes -> Hours -> Delta -> Clock\n>   addDelta (Clock h) (Minutes m) (Hours hr) (Delta d) = Clock (h + hr + (m + d) `div` 60)\n\n> main :: IO ()\n> main"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDeclare a module named \"Hamming\". Export only the distance function from the module.\nOutput:\n",
        "base_model": "\ndistance :: String -> String -> Int\ndistance \"karolin\" \"kathrin\" = 3\ndistance \"kathrin\" \"kerstin\" = 3\ndistance \"1011101\" \"1001001\" = 2\ndistance \"2173896\" \"2233796\" = 3\ndistance \"\", \"\" = 0\ndistance \"a\", \"a\" = 0\ndistance \"a\", \"b\" = 1\ndistance \"a\", \"ab\" = 1\ndistance \"ab\", \"a\" = 1\ndistance \"ab\", \"ac\" = 1\ndistance \"ac\", \"bc\" = 1\ndistance \"abc\", \"axc\" = 1\ndistance \"xabxcdxxefxgx\", \"1ab2cd34ef5g6\" = 6\ndistance \"nicolas\", \"nacho"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine the type signature of the distance function as taking two strings as input and returning a Maybe Int.\nOutput:\n",
        "base_model": "distance :: String -> String -> Maybe Int\n\nDefine the distance function to calculate the Levenshtein distance between two strings.\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nImplement the distance function to: Check if the lengths of the input strings are equal. If not, return Nothing. If equal, calculate the Hamming distance between the strings: Pair each character of the strings. Filter the pairs to keep only those with differing characters. Count the number of differing characters to get the Hamming distance. Wrap the distance in a Just constructor and return it.\nOutput:\n",
        "base_model": "\ndistance :: String -> String -> Maybe Int\ndistance \"karolin\" \"kathrin\" == Just 3\ndistance \"kathrin\" \"kerstin\" == Just 3\ndistance \"kerstin\" \"kathrin\" == Just 3\ndistance \"kerstin\" \"kerstin\" == Just 0\ndistance \"kerstin\" \"kerstinn\" == Nothing\ndistance \"jenny\" \"jen\" == Nothing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDeclare a module named Luhn and export the function isValid.\nOutput:\n",
        "base_model": "\nisValid :: Int -> Bool\nisValid n = ...\n\nInput:\n\nisValid :: Int -> Bool\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ...\n\nisValid n = ..."
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nImport the Data.Char module for character and string manipulation functions.\nOutput:\n",
        "base_model": "\n> module Main where\n> import Data.Char\n> main = do\n>   putStrLn \"Enter a string:\"\n>   str <- getLine\n>   putStrLn \"Enter a character:\"\n>   ch <- getChar\n>   let result = countOccurrences str ch\n>   putStrLn $ \"The character '\" ++ [ch] ++ \"' occurs \" ++ show result ++ \" times in the string.\"\n\n> countOccurrences :: String -> Char -> Int\n> countOccurrences str ch = length $ filter (== ch) str\n\nExplanation:\n\nThe main function prompts the user to enter a string and a character, reads them using getLine and getChar, respectively. It then calls the countOccurrences function with the entered string and character, and displays the result using putStrLn.\n\nThe countOccurrences function"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine a function called double that takes a String and returns another String. Call a helper function construct with the reversed input string s and an initial counter value of 1.\nOutput:\n",
        "base_model": "double \"Hello\"\n\"olleH\"\ndouble \"Hello World\"\n\"dlroW olleH\"\ndouble \"Hello World!\"\n\"dlroW olleH!\"\ndouble \"Hello World!\"\n\"dlroW olleH!\"\ndouble \"Hello World!\"\n\"dlroW olleH!\"\ndouble \"Hello World!\"\n\"dlroW olleH!\"\ndouble \"Hello World!\"\n\"dlroW olleH!\"\ndouble \"Hello World!\"\n\"dlroW olleH!\"\ndouble \"Hello World!\"\n\"dlroW olleH!\"\ndouble \"Hello World!\"\n\"dlroW olleH!\"\ndouble \"Hello World!\"\n\"dlroW olleH!\"\ndouble \"Hello World!\"\n\"dlroW olleH!\"\ndouble \"Hello World!\""
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nImplement the construct helper function to process the reversed string by doubling every second digit starting from the rightmost digit. Recursively process the rest of the string.\nOutput:\n",
        "base_model": "\nThe function should return a string containing the processed reversed string.\n\nSample Input:\n\n\"123456789\"\n\nSample "
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine a function named sumS that takes a String and returns an Int. Implement the sumS function to convert each character in the input string to its corresponding integer value, then calculate the sum of these integers.\nOutput:\n",
        "base_model": "sumS \"123\"\n6\nsumS \"abc\"\n9\nsumS \"123abc\"\n18\nsumS \"\"\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine a function named isValid that takes a String and returns a Bool. Implement the isValid function to check whether the input string represents a valid Luhn number. Filter out all non-digit characters, double every second digit, calculate the sum of all digits, and check if the sum is divisible by 10. Ensure that the normalized string is not \"0\". If both conditions are true, return True; otherwise, return False.\nOutput:\n",
        "base_model": "\n> isValid :: String -> Bool\n> isValid = ...\n\nTest Cases:\n\n*Main> isValid \"49927398716\"\nTrue\n*Main> isValid \"49927398717\"\nFalse\n*Main> isValid \"1234567812345678\"\nFalse\n*Main> isValid \"1234567812345670\"\nTrue\n*Main>"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDeclare the type signature for the nth function, specifying that it takes an Int as input and returns a Maybe Integer.\nOutput:\n",
        "base_model": "nth :: Int -> Maybe Integer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine the nth function with pattern matching. If n is less than 1, return Nothing to indicate an invalid input. If n equals 1, return Just 2 to indicate that the first prime number is 2. For any other value of n, calculate the n-th prime number using the isPrime function and the filter function.\nOutput:\n",
        "base_model": "\n> nth :: Integer -> Maybe Integer\n> nth n\n>   | n < 1 = Nothing\n>   | n == 1 = Just 2\n>   | otherwise = Just (filter isPrime [3,5..] !! (n-2))\n\nDefine the isPrime function with pattern matching. If n is less than 2, return False to indicate that n is not a prime number. If n is 2, return True to indicate that 2 is a prime number. For any other value of n, check if n is divisible by any number between 2 and the square root of n. If n is divisible by any of these numbers, return"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine the isPrime function, taking an integer i and returning a boolean indicating whether i is prime. Check whether there are no divisors for i other than 1 and i itself. Iterate over numbers from 3 up to the square root of i (rounded down) and check whether i is divisible by any of them. If none are divisors, i is prime.\nOutput:\n",
        "base_model": "\n> isPrime :: Int -> Bool\n> isPrime i = isPrime' i (floor (sqrt (fromIntegral i)))\n>   where\n>     isPrime' i 0 = True\n>     isPrime' i n = if i `mod` n == 0 then False else isPrime' i (n - 1)\n\nDefine the primes function, taking an integer n and returning a list of all prime numbers less than or equal to n. Iterate over numbers from 2 up to n and check whether each is prime. If it is, add it to the list"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine a Haskell module named GameOfLife with tick as its exported function.\nOutput:\n",
        "base_model": "tick :: GameOfLife -> GameOfLife\ntick is a function that takes a GameOfLife as input and returns a new GameOfLife that is one step further in the evolution of the game.\nInput:\ntype GameOfLife = [(Int, Int)]\nA GameOfLife is a list of coordinates of living cells.\nRules:\nAny live cell with fewer than two live neighbours dies, as if by underpopulation.\nAny live cell with two or three live neighbours lives on to the next generation.\nAny live cell with more than three live neighbours dies, as if by overpopulation.\nAny dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.\nExample:\ntick [(0, 0), (1, 0), (1, 1), (2, 1)]\n[(0, 0), (1, "
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nImplement the tick function, which takes a 2D list of integers ([[Int]]) representing the current state of the grid and returns a new 2D list of integers representing the next state after one iteration.\nOutput:\n",
        "base_model": "The tick function should return a new 2D list of integers representing the next state after one iteration.\nExample:\nInput:\n[[0, 0, 0, 0, 0],\n [0, 0, 1, 0, 0],\n [0, 0, 1, 0, 0],\n [0, 0, 1, 0, 0],\n [0, 0, 0, 0, 0]]\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nUse list comprehensions to iterate over each cell in the input matrix. Inside the list comprehension, define a nested function turnCell that takes the coordinates (x, y) of a cell and returns its new state based on the rules of the Game of Life.\nOutput:\n",
        "base_model": "The output should be a list of lists representing the updated matrix after applying the Game of Life rules.\n\nExample:\nInput:\n[[0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 0],\n [0, 0, 0, 0]]\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nUse pattern matching within turnCell to handle the current state of the cell (either 0 or 1). If the current cell is dead (0), use a conditional expression to determine its next state based on the number of live neighbors. If the current cell is alive (1), use another conditional expression to determine its next state based on the number of live neighbors.\nOutput:\n",
        "base_model": "\nThe output should be a list of lists representing the next generation of cells. Each inner list should contain the next generation of cells for a single row.\n\nExample:\n\nInput:\n\n[[0, 0, 0, 0, 0],\n [0, 0, 1, 0, 0],\n [0, 0, 1, 0, 0],\n [0, 0, 1, 0, 0],\n [0, 0, 0, 0, 0]]\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nImplement a helper function countLive that takes the coordinates (x, y) of a cell and calculates the number of live neighbors it has. Inside countLive, use list comprehensions to iterate over the neighboring cells and sum their values.\nOutput:\n",
        "base_model": "\ncountLive :: (Int, Int) -> Int\ncountLive (x, y) = sum [board !! (x + dx) !! (y + dy) | dx <- [-1..1], dy <- [-1..1], abs dx + abs dy /= 0, x + dx >= 0, x + dx < 5, y + dy >= 0, y + dy < 5]\n\nExplanation:\n\nThe function countLive takes a pair of integers (x, y) representing the coordinates of a cell in a 5x5 grid. It uses list comprehensions to generate a list of the values of the neighboring cells, excluding the cell itself. The sum of this list is returned as the result.\n\nInside the list comprehension, dx and"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nEnsure that cells at the edge of the grid are correctly handled by checking that their coordinates are within the valid range. Define a list indices containing the valid indices for both rows and columns of the matrix. Use this indices list to ensure that when calculating neighboring cell coordinates, they stay within the bounds of the matrix. Make sure to exclude the current cell from the neighbor count calculation.\nOutput:\n",
        "base_model": "\nThe function should return a matrix of the same dimensions as the input matrix.\n\nExample:\n\nInput:\n\n[[1, 2, 3],\n [4, 5, 6],\n [7, 8, 9]]\n\n"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nCreate a Haskell module named Triangle to encapsulate the functions related to generating Pascal's triangle.\nOutput:\n",
        "base_model": "\nPascal's triangle is a triangular array of the binomial coefficients.\n\nThe first line of the output is the number of lines in the triangle.\n\nThe second line is the number of elements in the first line.\n\nThe third line is the number of elements in the second line.\n\n...\n\nThe nth line is the number of elements in the nth line.\n\nThe elements in the Pascal's triangle are separated by a space.\n\nThe elements in each line are separated by a space.\n\nThe elements in the Pascal's triangle are separated by a space.\n\nThe elements in each line are separated by a space.\n\nThe elements in the Pascal's triangle are separated by a space.\n\nThe elements in each line are separated by a space.\n\nThe elements in the Pascal's triangle are separated by a space."
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nDefine the type signature of the rows function. It should take an integer n as input and return a list of lists of integers ([[Integer]]).\nOutput:\n",
        "base_model": "rows 0 == [[1]]\nrows 1 == [[1],[1,1]]\nrows 2 == [[1],[1,1],[1,2,1]]\nrows 3 == [[1],[1,1],[1,2,1],[1,3,3,1]]\nrows 4 == [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\nrows 5 == [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1]]\nrows 6 == [[1],[1,1],[1,2,1],[1"
    },
    {
        "prompt": "Instruct: You are a helpful assistant proficient in Haskell programming language. Please generate code strictly in Haskell based on the following descriptions and instructions.\nImplement the rows function using list comprehension or higher-order functions like take and map. rows should generate the first n rows of Pascal's triangle.\nOutput:\n",
        "base_model": "\nrows 5\n[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nrows 10\n[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36"
    }
]